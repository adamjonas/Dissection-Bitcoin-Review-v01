[[bitcoin-architecture]]
== 1.0 Bitcoin Architecture

=== Executables

To be able to interact with Bitcoin network, the user needs to connect to a Bitcoin node, a software whose main purposes are:

* Download the blockchain.
* Enforce the rules of the network.
* Validate and relay the transactions.

Running your own node is of utmost importance when spending or transferring the bitcoins. The other option is trusting other nodes which is a major security hole. When doing it, the user is not only leaking personal data, but also trusting in the data and in the rules defined by others, who can be malicious agents or harmful to the network or even harmful to the user.

The other component necessary to store and move coins is a wallet. The primary function of the wallet is to manage the private keys and sign transactions.

Bitcoin protocol does not have the concept of accounts, like banks. Wallets manage a pool of unfathomable random numbers called private keys, which should be kept secret by the user. Bitcoin addresses are derived from these private keys and they can be used to receive coins (and move them later). Only one receiving address must be used for each transaction.

Signing a transaction means the user is moving the money and has authorized the transaction. To create the signature, the wallet will use the private key associated to the coin(s) the user wants to spend.

Node and wallet are completely different things, although they can eventually come together in the same software. Node is related to bitcoin network and protocol while a wallet is related to the one’s private keys and transactions. It is very important to know the difference between these two concepts to be able to have a better understanding of Bitcoin architecture.

// ---

Bitcoin Core has been the reference implementation since its first version, and it is not only one software. Bitcoin Core is a solution that includes a node, a graphic interface, and a command line interface. There are also wallet features (including a sophisticated coin selection) but since version v0.21, wallets are no longer created by default. The reason is to make the use of multiple wallets more intuitive.

To start a node simple run the main app bitcoind implemented in src\bitcoind.cpp. This executable is expected to run as a daemon (in background). It also provides a REST interface, so anyone authorized can access and work with the node.

After running the daemon, the user will be able to interact with the node through a command-line application called bitcoin-cli that is implemented in src\bitcoin-cli.cpp. It implements some RPC commands that are sent via REST to the node (the bitcoind daemon) and process the results.

Another and simpler and friendly option to start the node and operate it is starting bitcoin-qt, implemented in src\qt\main.cpp. This one is an intuitive graphic interface, which all interactions happen through buttons. The user can create multiple wallets and check other information about the node as the peers’ connection and network statistics. 


.Bitcoin Core Executables
image::images/chapter_1_0/executables.svg[]
[CChainParams, align="center"]

{empty} +

=== Protocol - P2P

Bitcoin is a peer-to-peer protocol. There is no central server that can determine the rules. So, to be able to communicate with other peers and exchange information about the network, transactions and the chain state, the nodes need to establish a common protocol, so they can understand each other.

The file `src/protocol.h` defines all types of messages (`namespace NetMsgType`) that will be used in this communication. As can be seen in the code below, each message has a comment with a succinct description of its purpose.

[source,c++]  
----
/**
 * Bitcoin protocol message types. When adding new message types, don't forget
 * to update allNetMessageTypes in protocol.cpp.
 */
namespace NetMsgType {

/**
 * The version message provides information about the transmitting node to the
 * receiving node at the beginning of a connection.
 */
extern const char* VERSION;
/**
 * The verack message acknowledges a previously-received version message,
 * informing the connecting node that it can begin to send other messages.
 */
extern const char* VERACK;
// ...
/**
 * The inv message (inventory message) transmits one or more inventories of
 * objects known to the transmitting peer.
 */
extern const char* INV;
/**
 * The getdata message requests one or more data objects from another node.
 */
extern const char* GETDATA;
// ...
}
----

But how does the node find the other peers to exchange messages ? When running for first time, the node connect to a bunch of server denominated DNS Seeds which provides a list of IP addresses that are running (or were recently running) a Bitcoin client. After connecting to those IP addresses, the node starts to exchange messages and other new addresses with the peers. +
DNS seeds are  hardcoded and stored in `src/chainparams.cpp`.

[source,c++]  
----
vSeeds.emplace_back("seed.bitcoin.sipa.be"); // Pieter Wuille, only supports x1, x5, x9, and xd
vSeeds.emplace_back("dnsseed.bluematt.me"); // Matt Corallo, only supports x9
vSeeds.emplace_back("dnsseed.bitcoin.dashjr.org"); // Luke Dashjr
vSeeds.emplace_back("seed.bitcoinstats.com"); // Christian Decker, supports x1 - xf
vSeeds.emplace_back("seed.bitcoin.jonasschnelli.ch"); // Jonas Schnelli, only supports x1, x5, x9, and xd
----

New peers can be also manually added with the command `-addnode=<addr>`. The connection parameters, like `DEFAULT_MAX_PEER_CONNECTIONS` or `MAX_ADDNODE_CONNECTIONS`, can be found in the `net.h` file.

== Concurrency model

The class thread represents a single thread of execution. Threads allow multiple functions to execute concurrently.

Most threads are starded (directly or indirectly) in `init.cpp`.

=== `init.cpp:AppInitMain(...)` and `CConnman::Start(...)`

When the node starts, `init.cpp:AppInitMain(...)` calls `node.connman->Start(*node.scheduler, connOptions)`. In the `CConnman::Start(...)` the network-related threads are instantiated and excuted.

=== TraceThread

`TraceThread` is a wrapper for a function that just calls it once. It also names the thread and handles `boost::thread_interrupted` exception. In Bitcoin Core code, it is usually used as _fn_ argument to thread constructor `thread (Fn&& fn, Args&&... args)`.

[source,c++]  
----
template <typename Callable> void TraceThread(const char* name,  Callable func)
{
    util::ThreadRename(name);
    try
    {
        LogPrintf("%s thread start\n", name);
        func();
        LogPrintf("%s thread exit\n", name);
    }
    catch (const boost::thread_interrupted&)
    {
        LogPrintf("%s thread interrupt\n", name);
        throw;
    }
    catch (const std::exception& e) {
        PrintExceptionContinue(&e, name);
        throw;
    }
    catch (...) {
        PrintExceptionContinue(nullptr, name);
        throw;
    }
}
----

// Script Verification - nproc or 16 - ThreadScriptCheck()
// Loading blocks - 1 - ThreadImport()
=== Loading blocks

One of the first thing the node need to do is load the blocks and decides which chain to work.

The thread `g_load_block` invoke the function `void ThreadImport(...)` to load the blocks on startup. If the user is rebuilding the blockchain index (`-reindex`) or is loading blocks directly from files (`-loadblock`), it will be handled in this thread. After loding the blocks, it tries to find the best chain in `CChainState::ActivateBestChain(...)`.

It happens in the `init.cpp:AppInitMain(...)`.

[source,c++]  
----
std::vector<fs::path> vImportFiles;
for (const std::string& strFile : args.GetArgs("-loadblock")) {
    vImportFiles.push_back(strFile);
}

g_load_block = std::thread(&TraceThread<std::function<void()>>, "loadblk", [=, &chainman, &args] {
    ThreadImport(chainman, vImportFiles, args);
});
----

=== Servicing RPC Calls

To allow user to interact with the node, an HTTP server should be enabled to process the requests. In order to do it, the `init.cpp:AppInitServers(...)` calls `httpserver.cpp:InitHTTPServer()` `httpserver.cpp:StartHTTPServer()`.
The first method, as the name implies, initializes the server and the second one constructs new thread objects.

`g_thread_http` is event dispatcher thread, that manages the http event loop. It is interrupted when  InterruptHTTPServer() is called.

`g_thread_http_workers` distributes the work over multiple threads and handles longer requests off the event loop thread. `HTTPWorkQueueRun` is a simple wrapper to set thread name and run work queue. The number of the threads to service RPC calls is defined by the configuration argument `-rpcthreads` or `httpserver.h:DEFAULT_HTTP_THREADS`, whichever is greater.

[source,c++]  
----
static std::thread g_thread_http;
static std::vector<std::thread> g_thread_http_workers;

void StartHTTPServer()
{
    LogPrint(BCLog::HTTP, "Starting HTTP server\n");
    int rpcThreads = std::max((long)gArgs.GetArg("-rpcthreads", DEFAULT_HTTP_THREADS), 1L);
    LogPrintf("HTTP: starting %d worker threads\n", rpcThreads);
    g_thread_http = std::thread(ThreadHTTP, eventBase);

    for (int i = 0; i < rpcThreads; i++) {
        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue, i);
    }
}
----

=== Load Peer Adresses From DNS Seeds

As said before, the node initially queries the hardcoded DNS Seeds to find new peers to connect to.

`net.h:std::thread threadDNSAddressSeed` is a thread created with `CConnman::ThreadDNSAddressSeed(...)` wrapped into `TraceThread(...)`. It will run once when node starts.

It is called in `init.cpp:AppInitMain(...)` function with the command `node.connman->Start(*node.scheduler, connOptions)`.

Note if a particular list is provided in the configuration parameters ("-dnsseed"), this thread will not be instantiated.

[source,c++]  
----
if (!gArgs.GetBoolArg("-dnsseed", true))
    LogPrintf("DNS seeding disabled\n");
else
    threadDNSAddressSeed = std::thread(&TraceThread<std::function<void()> >, "dnsseed", std::function<void()>(std::bind(&CConnman::ThreadDNSAddressSeed, this)));
----

=== Send And Receive Messages To And From Peers

`std::thread threadSocketHandler` is created using `CConnman::ThreadSocketHandler()` method wrapped into `TraceThread(...)`.

[source,c++]  
----
bool CConnman::Start(...)
{
    threadSocketHandler = std::thread(&TraceThread<std::function<void()> >, "net", std::function<void()>(std::bind(&CConnman::ThreadSocketHandler, this)));
}
----

It seems strange at first, because `TraceThread(...)` ensures unique execution and the node will send and receive messages several time while connected, not just one time.

But a close look into the `CConnman::ThreadSocketHandler()` code shows it has  a loop that keeps running until be eventually interrupted by the `interruptNet` flag.

[source,c++]  
----
void CConnman::ThreadSocketHandler()
{
    while (!interruptNet)
    {
        DisconnectNodes();
        NotifyNumConnectionsChanged();
        SocketHandler();
    }
}
----

This flag is only set `false` in the `CConnman::Interrupt()` that interrupts all connections.

`CConnman::DisconnectNodes()` disconnect any connected nodes if the `fNetworkActive` is false. It can be disabled/enabled by `setnetworkactive` RPC command. The function also disconnects unused nodes and delete disconnected nodes.

`NotifyNumConnectionsChanged()` updates the numer of connections and ,if the client interface is enabled, it notifies when the number of connections change.

`SocketHandler()` handles socket connections, incoming messages (`pnode->vRecvMsg`) and the messages to send (`pnode->cs_vSend`);

=== Initializing Network Connections

The thread `std::thread threadOpenConnections` opens and manages connections to other peers. Before instantiating this thread, it is checked if the application is started with `-connect=0` or `-connect=<ip>`. +
If `-connect` is set to 0, this `threadOpenConnections` thread will not be created. +
If an specific IP is set, it will be the only one active outbound connection with that IP. +
If no "-connect" parameter is passed, all the outbound network connections will be initiate.

[source,c++]  
----
if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty())
        threadOpenConnections = std::thread(&TraceThread<std::function<void()> >, "opencon", std::function<void()>(std::bind(&CConnman::ThreadOpenConnections, this, connOptions.m_specified_outgoing)));
----

The total number of outbound connection `m_max_outbound` is defined in `src/net.h`. It usually will be 11, the sum of the full relay (8), block relay (2) only and feeler (1) connections.

[source,c++]  
----
/** Maximum number of automatic outgoing nodes over which we'll relay everything (blocks, tx, addrs, etc) */
static const int MAX_OUTBOUND_FULL_RELAY_CONNECTIONS = 8;
/** Maximum number of addnode outgoing nodes */
static const int MAX_ADDNODE_CONNECTIONS = 8;
/** Maximum number of block-relay-only outgoing connections */
static const int MAX_BLOCK_RELAY_ONLY_CONNECTIONS = 2;
/** Maximum number of feeler connections */
static const int MAX_FEELER_CONNECTIONS = 1;

void Init(...) {
    m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;
}
----

=== Process Messages from `net` -> `net_processing`

When the node starts, `init.cpp:AppInitMain(...)` calls `node.connman->Start(*node.scheduler, connOptions)`.

`std::thread threadMessageHandler` is created using CConnman::ThreadMessageHandler wrapped into `TraceThread(...)`.

[source,c++]  
----
bool CConnman::Start(...)
{
    // Process messages
    threadMessageHandler = std::thread(&TraceThread<std::function<void()> >, "msghand", std::function<void()>(std::bind(&CConnman::ThreadMessageHandler, this)));
}
----

It looks strange at first, because `TraceThread(...)` ensures unique execution and the node will process several messages, not just one.

The explanation is the code `CConnman::ThreadMessageHandler()` is a loop that keeps running until be eventually interrupted by the `flagInterruptMsgProc` flag.

This flag is only set `true` in the `CConnman::Interrupt()` that interrupts all connections.

[source,c++]  
----
void CConnman::ThreadMessageHandler()
{
    while (!flagInterruptMsgProc)
    {
        // ...

        for (CNode* pnode : vNodesCopy)
        {
            if (pnode->fDisconnect)
                continue;

            // Receive messages
            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);
            // ...
            // Send messages
            {
                LOCK(pnode->cs_sendProcessing);
                m_msgproc->SendMessages(pnode);
            }
            // ...
        }

        // ...
    }
}
----
