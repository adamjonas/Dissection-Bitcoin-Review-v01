[[bitcoin-architecture]]
== 1.0 Bitcoin Architecture

=== Executables

To be able to interact with Bitcoin network, the user needs to connect to a Bitcoin node, a software whose main purposes are:

* Download the blockchain.
* Enforce the rules of the network.
* Validate and relay the transactions.

Running your own node is of utmost importance when spending or transferring the bitcoins. The other option is trusting other nodes which is a major security hole. When doing it, the user is not only leaking personal data, but also trusting in the data and in the rules defined by others, who can be malicious agents or harmful to the network or even harmful to the user.

The other component necessary to store and move coins is a wallet. The primary function of the wallet is to manage the private keys and sign transactions.

Bitcoin protocol does not have the concept of accounts, like banks. Wallets manage a pool of unfathomable random numbers called private keys, which should be kept secret by the user. Bitcoin addresses are derived from these private keys and they can be used to receive coins (and move them later). Only one receiving address must be used for each transaction.

Signing a transaction means the user is moving the money and has authorized the transaction. To create the signature, the wallet will use the private key associated to the coin(s) the user wants to spend.

Node and wallet are completely different things, although they can eventually come together in the same software. Node is related to bitcoin network and protocol while a wallet is related to the oneâ€™s private keys and transactions. It is very important to know the difference between these two concepts to be able to have a better understanding of Bitcoin architecture.

Bitcoin Core has been the reference implementation since its first version. It is not just a single software. Bitcoin Core is a solution that includes a node, a graphical interface, and a command line interface. There are also wallet features (including a sophisticated coin selection) but since version v0.21, wallets are no longer created by default. The reason for this is to make the use of multiple wallets more intuitive.

To start a node, just run the main app bitcoind implemented in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/bitcoind.cpp[src/bitcoind.cpp]`. This executable is expected to run as a daemon (in the background). It also provides a REST interface, so anyone authorized can access and work with the node.

After running the daemon, the user will be able to interact with the node through a command-line application called bitcoin-cli that is implemented in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/bitcoin-cli.cpp[src/bitcoin-cli.cpp]`. It implements some RPC commands that are sent via REST to the node (the bitcoind daemon) and displays the results.

Another simpler and friendlier option to start the node and operate it is starting bitcoin-qt, implemented in `src/qt/main.cpp`. This is an intuitive graphical interface, where all interactions take place via buttons. The user can create multiple wallets and check other information about the node such as the peer connection and network statistics. 

// ---

.Bitcoin Core Executables
image::images/chapter_1_0/executables.svg[]
[CChainParams, align="center"]

{empty} +

=== Protocol - P2P

Bitcoin is a peer-to-peer protocol. There is no central server that can determine the rules. So, to be able to communicate with other peers and exchange informations, the nodes need to establish a common protocol, so they can understand each other.

The file `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/protocol.h[src/protocol.h]` defines all types of messages (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/protocol.h#L62[namespace NetMsgType]`) that will be used in this communication. As can be seen in the code below, each message has a comment with a succinct description of its purpose.

[source,c++]  
----
/**
 * Bitcoin protocol message types. When adding new message types, don't forget
 * to update allNetMessageTypes in protocol.cpp.
 */
namespace NetMsgType {

/**
 * The version message provides information about the transmitting node to the
 * receiving node at the beginning of a connection.
 */
extern const char* VERSION;
/**
 * The verack message acknowledges a previously-received version message,
 * informing the connecting node that it can begin to send other messages.
 */
extern const char* VERACK;
// ...
/**
 * The inv message (inventory message) transmits one or more inventories of
 * objects known to the transmitting peer.
 */
extern const char* INV;
/**
 * The getdata message requests one or more data objects from another node.
 */
extern const char* GETDATA;
// ...
}
----

But how does the node find the other peers to exchange messages ? When running for first time, the node connect to a bunch of server denominated DNS Seeds which provides a list of IP addresses that have recently been running a Bitcoin client. After connecting to those IP addresses, the node starts to exchange messages with the peers. +
DNS seeds are  hardcoded and stored in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/chainparams.cpp[src/chainparams.cpp]`.

[source,c++]  
----
vSeeds.emplace_back("seed.bitcoin.sipa.be"); // Pieter Wuille, only supports x1, x5, x9, and xd
vSeeds.emplace_back("dnsseed.bluematt.me"); // Matt Corallo, only supports x9
vSeeds.emplace_back("dnsseed.bitcoin.dashjr.org"); // Luke Dashjr
vSeeds.emplace_back("seed.bitcoinstats.com"); // Christian Decker, supports x1 - xf
vSeeds.emplace_back("seed.bitcoin.jonasschnelli.ch"); // Jonas Schnelli, only supports x1, x5, x9, and xd
----

New peers can be also manually added with the command `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L442[-addnode=<addr>]`. The connection parameters, like `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net.h#L78[DEFAULT_MAX_PEER_CONNECTIONS]` or `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net.h#L64[MAX_ADDNODE_CONNECTIONS]`, can be found in the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net.h[net.h]` file.

== Concurrency model

Bitcoin Core does a lot of things at the same time. It dowloads the blockchain, processes new transactions, validates new blocks, responds to the user events and to network events and so on. 

Therefore, a multithreaded application seems appropriate for this case. Threads allow multiple functions to be executed concurrently, improving considerably the application responsiveness. Multithreading also allows to use multiprocessors efficiently, enabling parallelism to perform intensive tasks.

An example of a task in the Bitcoin Core that can use multiple threads is the verification of scripts in a block. Since there are many transactions in a block, parallelizing the execution greatly improves performance.

Most threads are started (directly or indirectly) in `init.cpp:AppInitMain(...)`. This is the Bitcoin node main function. If the node is started through the `bitcoind` daemon, this function will be call inside the `src/bitcoind.cpp:AppInit(...)`. If it is started through the `bitcoin-qt` graphic interface, `src/interfaces/node.cpp:appInitMain(...)` will call this function.

Another relevant function is  `CConnman::Start(...)` since network-related threads are instantiated and excuted in it.

[source,c++]  
----
bool AppInitMain(...)
{
    // ...
    if (!node.connman->Start(*node.scheduler, connOptions)) {
        return false;
    }
    // ...
}
----

The table below shows the threads that will be presented next.

[%autowidth]
|===
|Purpose | # threads | Task run

|<<script-verification>>
|nproc or 16
|`ThreadScriptCheck()`

|<<loading-blocks>>
|1
|`ThreadImport()`

|<<servicing-rpc-calls>>
|4 or more
|`ThreadHTTP()`

|<<load-peer-adresses-from-dns-seeds>>
|1
|`ThreadDNSAddressSeed()`

|<<send-and-receive-messages-to-and-from-peers>>
|1
|`ThreadSocketHandler()`

|<<initializing-network-connections>>
|1
|`ThreadOpenConnections()`


|<<opening-added-network-connections>>
|1
|`ThreadOpenAddedConnections()`

|<<process-messages-from-net-net-processing>>
|1
|`ThreadMessageHandler()`

|===


=== TraceThread

`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.h#L432[TraceThread]` is a wrapper for a function that just calls it once. It also names the thread and handles `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.h#L441[boost::thread_interrupted]` exception. In Bitcoin Core code, it is usually used as _fn_ argument to thread constructor `std::thread (Fn&& fn, Args&&... args)`. It is defined in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.h[src/util/system.h]`.

[source,c++]  
----
template <typename Callable> void TraceThread(const char* name,  Callable func)
{
    util::ThreadRename(name);
    try
    {
        LogPrintf("%s thread start\n", name);
        func();
        LogPrintf("%s thread exit\n", name);
    }
    catch (const boost::thread_interrupted&)
    {
        LogPrintf("%s thread interrupt\n", name);
        throw;
    }
    catch (const std::exception& e) {
        PrintExceptionContinue(&e, name);
        throw;
    }
    catch (...) {
        PrintExceptionContinue(nullptr, name);
        throw;
    }
}
----

[[script-verification]]
=== Script Verification

The function that perform the script verification is `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/script/interpreter.cpp#L1937[bool src/script/interpreter.cpp:VerifyScript(...)]`. It is called in at least three points of the application:

* When the node receives a new transaction, which is handled by `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2274[void src/net_processing.cpp:PeerManager::ProcessMessage(...)]` when the received message is a _tx_ type (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2940[if (msg_type == NetMsgType::TX)]`).

* When the node wants to broadcast a new transaction. It is done by `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/node/transaction.cpp#L29[TransactionError src/node/transaction.cpp:BroadcastTransaction(...)]`.

* When receiving a new block, `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2274[void net_src/processing.cpp:PeerManager::ProcessMessage(...)]` will identify a _getblocks_ message type (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2754[if (msg_type == NetMsgType::GETBLOCKS)]`) and https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2779[will call] `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2744[bool src/validation.cpp:CChainState::ActivateBestChain(...)]`.

In the fist two case, `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1062[static bool validation.cpp:AcceptToMemoryPool(...)]` function is called to handle the new transaction, as can be seen in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L3006[ProcessMessage(...)]` and `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/node/transaction.cpp#L66[BroadcastTransaction(...)]`. It will try to add the transaction to mempool. In the last case, the function that will handle the new block is `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1946[bool src/validation.cpp:CChainState::ConnectBlock(...)]`. Both of them end up calling `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1516[src/validation.cpp:bool CheckInputScripts(...)]`.

`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1516[CheckInputScripts(...)]` validates the scripts of all the inputs of the `const CTransaction& tx` transaction passed as parameter. However, the relevant parameter in this context is the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L201[std::vector<CScriptCheck> *pvChecks = nullptr]`. `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.h#L252[CScriptCheck]` is a closure representing one script verification and it stores references to the spending transaction.

[source,c++]  
----
class CScriptCheck
{
    private:
        CTxOut m_tx_out;
        const CTransaction *ptxTo;
        unsigned int nIn;
        unsigned int nFlags;
        bool cacheStore;
        ScriptError error;
        PrecomputedTransactionData *txdata;
    // ...
}
----

The `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.h#L252[CScriptCheck]` method that matters is the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1464[bool src/validation.cpp:CScriptCheck::operator()()]`. It overloads the operator `()` and perform the script validation (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1467[VerifyScript(...)]`).

[source,c++]  
----
bool CScriptCheck::operator()() {
    const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;
    const CScriptWitness *witness = &ptxTo->vin[nIn].scriptWitness;
    return VerifyScript(scriptSig, m_tx_out.scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, m_tx_out.nValue, cacheStore, *txdata), &error);
}
----

So if the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1561[std::vector<CScriptCheck> *pvChecks]` is not null, the  `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1516[CheckInputScripts(...)]` will add each script validation (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1560[CScriptCheck check]`) to the vector, so they can be executed in parallel. Otherwise, the script is verified immediately.

[source,c++]  
----
bool CheckInputScripts(const CTransaction& tx, ..., std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
{
    // ...
    for (unsigned int i = 0; i < tx.vin.size(); i++) {
        CScriptCheck check(txdata.m_spent_outputs[i], tx, i, flags, cacheSigStore, &txdata);
        if (pvChecks) {
            pvChecks->push_back(CScriptCheck());
            check.swap(pvChecks->back());
        } else if (!check()) {
            // ...
        }
        // ...
    }
    // ...
}
----

The only function that makes use of script validation parallelization is the aforementioned `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1946[bool CChainState::ConnectBlock(...)]` due to the quantity of transactions in a block. If the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2134[g_parallel_script_checks]` is true, the script verification vector that has been filled in `CheckInputScripts(...)` is allocated in  `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2134[CCheckQueueControl<CScriptCheck> control(...)]`. The `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2218[control.Wait()]` initiates the their execution and wait for the end. +
`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L135[g_parallel_script_checks]` is a global parameter and it will be better detailed soon.

[source,c++]  
----
bool CChainState::ConnectBlock(const CBlock& block, ...)
{
    // ...
    CCheckQueueControl<CScriptCheck> control(fScriptChecks && g_parallel_script_checks ? &scriptcheckqueue : nullptr);
    // ...

    for (unsigned int i = 0; i < block.vtx.size(); i++)
    {
        if (!tx.IsCoinBase())
        {
            std::vector<CScriptCheck> vChecks;
            if (!CheckInputScripts(tx,..., g_parallel_script_checks ? &vChecks : nullptr)) { /*...*/ }
            control.Add(vChecks);  
        }
    }

    if (!control.Wait()) {
        LogPrintf("ERROR: %s: CheckQueue failed\n", __func__);
        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, "block-validation-failed");
    }
}
----

The code that will be excute the work (in this case, it is the script verification) can be found in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/checkqueue.h#L66[bool src/checkqueue.h:CCheckQueue::Loop(...)]`.

[source,c++]  
----
template <typename T>
class CCheckQueue
{
private:
    /** Internal function that does bulk of the verification work. */
    bool Loop(bool fMaster = false)
    {
        // ...
        do {
            // ...
            // execute work
            for (T& check : vChecks)
                if (fOk)
                    fOk = check();
            vChecks.clear();
        } while (true);
}
----

The number of script-checking threads is defined in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1263[init.cpp:AppInitMain(...)]`. The user can set the number of the threads using the argument `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L418[-par]`. If the number is negative, it will limit the threads. +
If the user does not pass the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L418[-par]` parameter, `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.cpp#L1277[src/util/system.cpp:GetNumCores()]` is called to get the number of concurrent threads supported by the implementation. Then 1 is subtracted from this number because the the main thread is already being  used. `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.cpp#L1277[GetNumCores()]` is just a wrapper for C++ standard function `std::thread::hardware_concurrency()`. +
There is also a maximum number of dedicated script-checking threads allowed, that is 15 (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.h#L70[MAX_SCRIPTCHECK_THREADS]`).
Note that `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1333[g_parallel_script_checks]` is set to true, allowing parallelization in the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1946[ConnectBlock(...)]` function.

[source,c++]  
----
bool AppInitMain(...)
{
    //...
    int script_threads = args.GetArg("-par", DEFAULT_SCRIPTCHECK_THREADS);
    if (script_threads <= 0) {
        // -par=0 means autodetect (number of cores - 1 script threads)
        // -par=-n means "leave n cores free" (number of cores - n - 1 script threads)
        script_threads += GetNumCores();
    }

    // Subtract 1 because the main thread counts towards the par threads
    script_threads = std::max(script_threads - 1, 0);

    // Number of script-checking threads <= MAX_SCRIPTCHECK_THREADS
    script_threads = std::min(script_threads, MAX_SCRIPTCHECK_THREADS);

    LogPrintf("Script verification uses %d additional threads\n", script_threads);
    if (script_threads >= 1) {
        g_parallel_script_checks = true;
        for (int i = 0; i < script_threads; ++i) {
            threadGroup.create_thread([i]() { return ThreadScriptCheck(i); });
        }
    }
    //...
}
----

And finally the command `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1335[ThreadScriptCheck(i)]` simply initiates a new worker thread one or several times, according to the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1318[script_threads]` value. Its implementation can be found in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1823[src/validation.cpp]`.

[source,c++]  
----
static CCheckQueue<CScriptCheck> scriptcheckqueue(128);

void ThreadScriptCheck(int worker_num) {
    util::ThreadRename(strprintf("scriptch.%i", worker_num));
    scriptcheckqueue.Thread();
}
----

Therefore, these are the main steps in verifying the script. However, there is already a change after version v0.21, making it more efficient and reducing the dependency on `boost / thread`. It can be verified in the  https://github.com/bitcoin/bitcoin/pull/18710[PR #18710]. There is also an interesting https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/test/checkqueue_tests.cpp[CCheckQueue unit tests], implemented in the https://github.com/bitcoin/bitcoin/pull/9497/files[PR #9497].

[[loading-blocks]]
=== Loading Blocks

One of the first thing the node need to do is load the blocks and decides which chain to work.

The thread `g_load_block` invoke the function `void ThreadImport(...)` to load the blocks on startup. If the user is rebuilding the blockchain index (`-reindex`) or is loading blocks directly from files (`-loadblock`), it will be handled in this thread. After loading the blocks, it tries to find the best chain in `CChainState::ActivateBestChain(...)`.

It happens in the `init.cpp:AppInitMain(...)`.

[source,c++]  
----
std::vector<fs::path> vImportFiles;
for (const std::string& strFile : args.GetArgs("-loadblock")) {
    vImportFiles.push_back(strFile);
}

g_load_block = std::thread(&TraceThread<std::function<void()>>, "loadblk", [=, &chainman, &args] {
    ThreadImport(chainman, vImportFiles, args);
});
----

[[servicing-rpc-calls]]
=== Servicing RPC Calls

To allow user to interact with the node, an HTTP server should be enabled to process the requests. In order to do it, the `init.cpp:AppInitServers(...)` calls `httpserver.cpp:InitHTTPServer()` that, as the name implies, initializes the server and `httpserver.cpp:StartHTTPServer()` that constructs new thread objects.

`g_thread_http` is event dispatcher thread, that manages the http event loop. It is interrupted when  InterruptHTTPServer() is called.

`g_thread_http_workers` distributes the work over multiple threads and handles longer requests off the event loop thread. `HTTPWorkQueueRun` is a simple wrapper to set thread name and run work queue. The number of the threads to service RPC calls is defined by the configuration argument `-rpcthreads` or `httpserver.h:DEFAULT_HTTP_THREADS=4`, whichever is greater.

[source,c++]  
----
static std::thread g_thread_http;
static std::vector<std::thread> g_thread_http_workers;

void StartHTTPServer()
{
    LogPrint(BCLog::HTTP, "Starting HTTP server\n");
    int rpcThreads = std::max((long)gArgs.GetArg("-rpcthreads", DEFAULT_HTTP_THREADS), 1L);
    LogPrintf("HTTP: starting %d worker threads\n", rpcThreads);
    g_thread_http = std::thread(ThreadHTTP, eventBase);

    for (int i = 0; i < rpcThreads; i++) {
        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue, i);
    }
}
----

[[load-peer-adresses-from-dns-seeds]]
=== Load Peer Adresses From DNS Seeds

As said before, the node initially queries the hardcoded DNS Seeds to find new peers to connect to.

`net.h:std::thread threadDNSAddressSeed` is a thread created with `CConnman::ThreadDNSAddressSeed(...)` wrapped into `TraceThread(...)`. It will run once when node starts.

It is called in `init.cpp:AppInitMain(...)` function when the command `node.connman->Start(*node.scheduler, connOptions)` is executed.

Note if a particular list is provided in the configuration parameters (`-dnsseed`), this thread will not be instantiated.

[source,c++]  
----
if (!gArgs.GetBoolArg("-dnsseed", true))
    LogPrintf("DNS seeding disabled\n");
else
    threadDNSAddressSeed = std::thread(&TraceThread<std::function<void()> >, "dnsseed", std::function<void()>(std::bind(&CConnman::ThreadDNSAddressSeed, this)));
----

[[send-and-receive-messages-to-and-from-peers]]
=== Send And Receive Messages To And From Peers

`std::thread threadSocketHandler` is created using `CConnman::ThreadSocketHandler()` method wrapped into `TraceThread(...)`.

[source,c++]  
----
bool CConnman::Start(...)
{
    threadSocketHandler = std::thread(&TraceThread<std::function<void()> >, "net", std::function<void()>(std::bind(&CConnman::ThreadSocketHandler, this)));
}
----

It seems strange at first, because `TraceThread(...)` ensures unique execution and the node will send and receive messages several time while connected, not just one time.

But a close look into the `CConnman::ThreadSocketHandler()` code shows it has  a loop that keeps running until be eventually interrupted by the `interruptNet` flag.

[source,c++]  
----
void CConnman::ThreadSocketHandler()
{
    while (!interruptNet)
    {
        DisconnectNodes();
        NotifyNumConnectionsChanged();
        SocketHandler();
    }
}
----

This flag is set `false` only in the `CConnman::Interrupt()` that interrupts all connections.

`CConnman::DisconnectNodes()` disconnect any connected nodes if the `fNetworkActive` is false. It can be disabled/enabled by `setnetworkactive` RPC command. The function also disconnects unused nodes and delete disconnected nodes.

`NotifyNumConnectionsChanged()` updates the nubmer of connections and ,if the client interface is enabled, it notifies when the number of connections change.

`SocketHandler()` handles socket connections, incoming messages (`pnode->vRecvMsg`) and the messages to send (`pnode->cs_vSend`);

[[initializing-network-connections]]
=== Initializing Network Connections

The thread `std::thread threadOpenConnections` opens and manages connections to other peers. Before instantiating this thread, it is checked if the application is started with `-connect=0` or `-connect=<ip>`. +
If `-connect` is set to 0, this `threadOpenConnections` thread will not be created. +
If an specific IP is set, there will be only one active outbound connection and with that IP. +
If the `-connect` parameter is not passed, all the outbound network connections will be initiate.

[source,c++]  
----
if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty())
        threadOpenConnections = std::thread(&TraceThread<std::function<void()> >, "opencon", std::function<void()>(std::bind(&CConnman::ThreadOpenConnections, this, connOptions.m_specified_outgoing)));
----

The total number of outbound connection `m_max_outbound` is defined in `src/net.h`. It usually will be 11, the sum of the full relay (8), block relay (2) only and feeler (1) connections.

[source,c++]  
----
/** Maximum number of automatic outgoing nodes over which we'll relay everything (blocks, tx, addrs, etc) */
static const int MAX_OUTBOUND_FULL_RELAY_CONNECTIONS = 8;
/** Maximum number of addnode outgoing nodes */
static const int MAX_ADDNODE_CONNECTIONS = 8;
/** Maximum number of block-relay-only outgoing connections */
static const int MAX_BLOCK_RELAY_ONLY_CONNECTIONS = 2;
/** Maximum number of feeler connections */
static const int MAX_FEELER_CONNECTIONS = 1;

void Init(...) {
    m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;
}
----

The use of `-connect=0` to disable automatic outbound connections has been implemented in https://bitcoin.org/en/release/v0.14.0#p2p-protocol-and-network-code[v0.14], with the the https://github.com/bitcoin/bitcoin/pull/9002[PR #9002].

[[opening-added-network-connections]]
=== Opening Added Network Connections

`std::thread threadMessageHandler` is created using `CConnman::ThreadOpenAddedConnections` wrapped into `TraceThread(...)`.

`CConnman::ThreadOpenAddedConnections()` calls `CConnman::GetAddedNodeInfo()` to retrieve the nodes that has been` added manually and try to open connection with them calling `OpenNetworkConnection(...)`.

[source,c++]  
----
// Initiate manual connections
threadOpenAddedConnections = std::thread(&TraceThread<std::function<void()> >, "addcon", std::function<void()>(std::bind(&CConnman::ThreadOpenAddedConnections, this)));
----

[[process-messages-from-net-net-processing]]
=== Process Messages from `net` -> `net_processing`

When the node starts, `init.cpp:AppInitMain(...)` calls `node.connman->Start(*node.scheduler, connOptions)`.

`std::thread threadMessageHandler` is created using `CConnman::ThreadMessageHandler` wrapped into `TraceThread(...)`.

[source,c++]  
----
bool CConnman::Start(...)
{
    // Process messages
    threadMessageHandler = std::thread(&TraceThread<std::function<void()> >, "msghand", std::function<void()>(std::bind(&CConnman::ThreadMessageHandler, this)));
}
----

As already seen in <<send-and-receive-messages-to-and-from-peers>>, this code will not be executed once. `TraceThread(...)` ensures unique execution but the `CConnman::ThreadMessageHandler()` has a loop that keeps running until be eventually interrupted by the `flagInterruptMsgProc` flag.

This flag is set `true` only in the `CConnman::Interrupt()` that interrupts all connections.

[source,c++]  
----
void CConnman::ThreadMessageHandler()
{
    while (!flagInterruptMsgProc)
    {
        // ...

        for (CNode* pnode : vNodesCopy)
        {
            if (pnode->fDisconnect)
                continue;

            // Receive messages
            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);
            // ...
            // Send messages
            {
                LOCK(pnode->cs_sendProcessing);
                m_msgproc->SendMessages(pnode);
            }
            // ...
        }

        // ...
    }
}
----

=== Notifications Mechanism (`ValidationInterface`)

A lot of event happen at same time in Bitcoin Core: new messages arrive all the time, are processed and sometime, announcements need to be made. For example, if a wallet is connected to Bitcoin Core and a transaction related to this wallet arrives, the wallet needs to be notified; when a new block arrives, the chain and the wallet need to be updated; transaction can also be removed from mempool and it needs to be notified and so on.

In a good software architecture, the components that trigger notifications and those that listen to them are completely decoupled. The message producer sends the notification to the listeners, but it does not know (and does not care) how the message will be processed by the recipient. The sender's main concern should be to ensure that the message is delivered and to do this asynchronously, so as not to block any execution.

A known pattern for asynchronous message service is called _message queue_. When a relevant event is triggered, a message will be are stored on the queue until they are processed by the consumer and deleted. The class that implement this kind of service in Bitcoin Core is the `CScheduler` and the method that keeps the queue running is `void CScheduler::serviceQueue()`. The queue service is started as soon as the application is initiated on `AppInitMain(...)`. This service will be more detailed later.

[source,c++]  
----
bool AppInitMain(...)
{
    // Start the lightweight task scheduler thread
    threadGroup.create_thread([&] { TraceThread("scheduler", [&] { node.scheduler->serviceQueue(); }); });
}
----

In Bitcoin Core, there are two main classes that implements the notification between the components, the `CValidationInterface`, that works as notification receivers (also known as _subscribers_ ) and the `CMainSignals`, that works as unique notification sender (also known as _publisher_). When some event needs to be published, the message is sent by `static CMainSignals g_signals` to all the subscribers.

// Not ZMQ

`CValidationInterface` is the interface that any class interested in listening to the events should implement. The events are: `UpdatedBlockTip`, `TransactionAddedToMempool`, `TransactionRemovedFromMempool`, `BlockConnected`, `BlockDisconnected, `ChainStateFlushed`, `BlockChecked` and `NewPoWValidBlock`. 

[source,c++]  
----
class CValidationInterface {
protected:
    ~CValidationInterface() = default;
    virtual void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) {}

    virtual void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {}

    virtual void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {}
    
    virtual void BlockConnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex *pindex) {}
    
    virtual void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) {}
    
    virtual void ChainStateFlushed(const CBlockLocator &locator) {}
    
    virtual void BlockChecked(const CBlock&, const BlockValidationState&) {}
    
    virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};
    friend class CMainSignals;
};
----

All of these methods represent the events and although they are defined as `virtual`, they have an empty default implementation `{}`. So the subclasses only needs to implement the methods / events that matter.

The classes that implement them are `src/net_processing.h:PeerManager`, `src/index/base.h:BaseIndex`, `src/interfaces/chain.cpp:NotificationsProxy`, `src/rpc/mining.cpp:submitblock_StateCatcher` and `src/zmq/zmqnotificationinterface:CZMQNotificationInterface`.

The code below shows `PeerManager` implementing `CValidationInterface`. Note that the class does not implement the `TransactionAddedToMempool`, `TransactionRemovedFromMempool`,  `ChainStateFlushed`, what means it have no interest in these events.

[source,c++]  
----
class PeerManager final : public CValidationInterface, public NetEventsInterface {
    /**
     * Overridden from CValidationInterface.
     */
    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;
    void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) override;
    /**
     * Overridden from CValidationInterface.
     */
    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;
    /**
     * Overridden from CValidationInterface.
     */
    void BlockChecked(const CBlock& block, const BlockValidationState& state) override;
    /**
     * Overridden from CValidationInterface.
     */
    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;
    // ..
}
----

But it is not enough to just implement those methods. To be able to listen to these events, it is necessary to register them as subscribers of `CMainSignals`, which is the unique publisher, so they can receive the notifications. It is done registering the `CValidationInterface` object through the `RegisterSharedValidationInterface(...)` or `RegisterValidationInterface(...)` functions.

`PeerManager`, `BaseIndex`, `CZMQNotificationInterface` use `RegisterValidationInterface(...)` while `NotificationsProxy`, `submitblock_StateCatcher` use `RegisterSharedValidationInterface(...)`. The codes below illustrate this.

[source,c++]  
----
bool AppInitMain(...)
{
    // ...
    node.peerman.reset(new PeerManager(chainparams, *node.connman, node.banman.get(), *node.scheduler, chainman, *node.mempool));
    RegisterValidationInterface(node.peerman.get());
    // ...
#if ENABLE_ZMQ
    g_zmq_notification_interface = CZMQNotificationInterface::Create();

    if (g_zmq_notification_interface) {
        RegisterValidationInterface(g_zmq_notification_interface);
    }
#endif
    //...
}
----
[source,c++]  
----
static RPCHelpMan submitblock()
{
    // ...
    auto sc = std::make_shared<submitblock_StateCatcher>(block.GetHash());
    RegisterSharedValidationInterface(sc);
    bool accepted = EnsureChainman(request.context).ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true, /* fNewBlock */ &new_block);
    UnregisterSharedValidationInterface(sc);
    // ...
}
----

Calling any of the two methods has the same effect. `RegisterValidationInterface(...)` receives raw pointer as parameter, then convert it to a shared pointer with empty block control and send it to the `RegisterSharedValidationInterface(...)`. Note that the NotificationsProxy` and `submitblock_StateCatcher` classes, that call directly `RegisterSharedValidationInterface(...)`  use `std::make_shared` to wrap the argument in a `std::shared_ptr`. The others call `RegisterValidationInterface(...)`. +
Using shared pointers instead of raw pointers ensures the pointer is only deleted when the last reference is deleted. More details can be found in the https://github.com/bitcoin/bitcoin/pull/18338[PR #18338].

[source,c++]  
----
void RegisterSharedValidationInterface(std::shared_ptr<CValidationInterface> callbacks)
{
    // Each connection captures the shared_ptr to ensure that each callback is
    // executed before the subscriber is destroyed. For more details see #18338.
    g_signals.m_internals->Register(std::move(callbacks));
}

void RegisterValidationInterface(CValidationInterface* callbacks)
{
    // Create a shared_ptr with a no-op deleter - CValidationInterface lifecycle
    // is managed by the caller.
    RegisterSharedValidationInterface({callbacks, [](CValidationInterface*){}});
}
----

To register a new subscriber, `RegisterSharedValidationInterface(...)` calls `g_signals.m_internals->Register(...)`. +
`g_signals` is a static `CMainSignals` that, as said before, is the unique publisher and `m_internals` is `MainSignalsInstance` struct.

This struct has two important properties: `std::list<ListEntry> m_list` and `SingleThreadedSchedulerClient m_schedulerClient`. The first one is the list that stores the references for all the subscribers (objects that implement `CValidationInterface` interface) and the second one queues the messages to be sent and executes them serially.

[source,c++]  
----
struct MainSignalsInstance {
private:
    struct ListEntry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };
    std::list<ListEntry> m_list GUARDED_BY(m_mutex);
    // ...
public:
    SingleThreadedSchedulerClient m_schedulerClient;

    void Register(std::shared_ptr<CValidationInterface> callbacks)
    {
        // Register a new CValidationInterface subscriber
    }

    // ...
}
----

`CMainSignals` is the class that broadcast the notifications to all the subscribers. Note the some methods of this class have the same name of the `CValidationInterface` class. This way, it is easy to identify which event is being triggered, since both the publisher and the subscriber use the same name for the methods. Note that `CMainSignals` _does not_ implement `CValidationInterface`, the methods having the same name is just a design decision.

[source,c++]  
----
class CMainSignals {
private:
    std::unique_ptr<MainSignalsInstance> m_internals;

    // ...

public:
    
    // ...

    void UpdatedBlockTip(const CBlockIndex *, const CBlockIndex *, bool fInitialDownload);
    void TransactionAddedToMempool(const CTransactionRef&, uint64_t mempool_sequence);
    void TransactionRemovedFromMempool(const CTransactionRef&, MemPoolRemovalReason, uint64_t mempool_sequence);
    void BlockConnected(const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex);
    void BlockDisconnected(const std::shared_ptr<const CBlock> &, const CBlockIndex* pindex);
    void ChainStateFlushed(const CBlockLocator &);
    void BlockChecked(const CBlock&, const BlockValidationState&);
    void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);
};
----

To notify each of the subscribers, the `MainSignalsInstance m_internals` iterates each `CValidationInterface` element (which is also called `callback`) and constructs a lambda with the params that the message have (in case of `TransactionAddedToMempool`, they are the `tx` and `mempool_sequence`). The lambda body is the execution of `CValidationInterface::TransactionAddedToMempool(...)`. Instead of running the lambda immediately, it is allocated in the `SingleThreadedSchedulerClient m_schedulerClient` to be executed serially.

[source,c++]  
----
#define ENQUEUE_AND_LOG_EVENT(event, fmt, name, ...)           \
    do {                                                       \
        auto local_name = (name);                              \
        LOG_EVENT("Enqueuing " fmt, local_name, __VA_ARGS__);  \
        m_internals->m_schedulerClient.AddToProcessQueue([=] { \
            LOG_EVENT(fmt, local_name, __VA_ARGS__);           \
            event();                                           \
        });                                                    \
    } while (0)
// ...
void CMainSignals::TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {
    auto event = [tx, mempool_sequence, this] {
        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.TransactionAddedToMempool(tx, mempool_sequence); });
    };
    ENQUEUE_AND_LOG_EVENT(event, "%s: txid=%s wtxid=%s", __func__,
                          tx->GetHash().ToString(),
                          tx->GetWitnessHash().ToString());
}
----

And finally, to trigger an event, it is only needed to call `GetMainSignals().[event_name]`. The `MemPoolAccept::AcceptSingleTransaction` function below illustrates it, sending the notification that a new transaction is added to mempool, passing as parameters the transaction and the mempool sequence.

[source,c++]  
----
bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args)
{
    // ...

    GetMainSignals().TransactionAddedToMempool(ptx, m_pool.GetAndIncrementSequence());

    return true;
}
----

The diagram below shows the notifications classes (and some of their fields) presented so far.

.Notification Class Diagram
image::images/chapter_1_0/notification_classes.svg[]
[CChainParams, align="center"]

=== Regions

=== `net.{h,cpp}`

// std::unique_ptr<CAddrMan> addrman;
// std::unique_ptr<CConnman> connman;
// std::unique_ptr<PeerManager> peerman;
// std::unique_ptr<BanMan> banman;
// std::unique_ptr<CScheduler> scheduler;

The `src/net.{h,cpp}` files implement the most basic network level. It is the "bottom" of the Bitcoin Core stack. It handles network communication with the P2P network.

// node.connman = std::make_unique<CConnman>(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max()), *node.addrman, args.GetBoolArg("-networkactive", true));
// nSeed0 & nSeed1In - id

The network connection is enabled when `!node.connman->Start(*node.scheduler, connOptions)` is called in the application main function `src.cpp:AppInitMain(...)`. The `node` variable refers to the `struct NodeContext`. It is a struct containing references to chain state and connection state. This is used by the init function, RPC, GUI and test code to pass object references around
without needing to declare the same variables and parameters repeatedly, or to use globals. The struct is defined in `src/node/context.h`.

Before this struct was created, the global variable `g_conman` was used to manage the connection. But using global variables reduces the modularity and flexibility of the program, so the https://github.com/bitcoin/bitcoin/pull/16839[PR #16839] has got rid of the some global variables and has made `g_conman` a NodeContext member (now it is called `connman`).

[source,c++]  
----
struct NodeContext {
    std::unique_ptr<CAddrMan> addrman;
    std::unique_ptr<CConnman> connman;
    std::unique_ptr<CTxMemPool> mempool;
    std::unique_ptr<CBlockPolicyEstimator> fee_estimator;
    std::unique_ptr<PeerManager> peerman;
    // ...
}
----

The `connOptions` parameter is a `CConnman::Options` object. It stores many of configurable network parameters the user can define when starting the node. If no parameters are defined, the default values are in `net.h`.

[source,c++]  
----
// src/init.cpp
bool AppInitMain(...)
{
    // ...
    CConnman::Options connOptions;
    connOptions.nLocalServices = nLocalServices;
    connOptions.nMaxConnections = nMaxConnections;
    connOptions.m_max_outbound_full_relay = std::min(MAX_OUTBOUND_FULL_RELAY_CONNECTIONS, connOptions.nMaxConnections);
    connOptions.m_max_outbound_block_relay = std::min(MAX_BLOCK_RELAY_ONLY_CONNECTIONS, connOptions.nMaxConnections-connOptions.m_max_outbound_full_relay);
    connOptions.nMaxAddnode = MAX_ADDNODE_CONNECTIONS;
    connOptions.nMaxFeeler = MAX_FEELER_CONNECTIONS;
    // ...
}
----

The `scheduler` parameter is a `CScheduler` object. In this function, it is used to schedule how often the peer IP addresses will be stored on the disk. In this case, it is 15 minutes, as defined in the `DUMP_PEERS_INTERVAL` variable.  The file that stores information about the peers is called `peers.dat`.

The function `bool CConnman::Start(...)` loads the addresses from peers.dat and stores them in `CAddrMan& addrman` variable. `CAddrMan` has a table with information about all stored peers, the `std::map<int, CAddrInfo> mapInfo`, and oanther field with the peers ID and their network addresses, the `std::map<CNetAddr, int> mapAddr`.

Then, the file `anchors.dat` is deserialized. This file contains addresses that were saved during the previous clean shutdown. 
The node will attempt to make block-relay-only connections to them.
These addresses are stored in `std::vector<CAddress> m_anchors`.

The reason there are two files is a risk mitigation measure implemented in the https://github.com/bitcoin/bitcoin/pull/15759[PR #15759] and the https://github.com/bitcoin/bitcoin/pull/17428[PR #17428]. The first change was motivated by the https://arxiv.org/pdf/1812.00942.pdf[TxProbe] paper, which  describes that transaction relay leaks information that adversaries can use to infer the network topology. The second one was motivated by the https://eprint.iacr.org/2015/263.pdf[Eclipse Attack] paper, that presents an attack that allows an adversary controlling a sufficient number of IP addresses to monopolize all connections to and from a victim bitcoin node.

[source,c++]  
----
bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)
{
    // ...
    // Load addresses from peers.dat
    int64_t nStart = GetTimeMillis();
    {
        CAddrDB adb;
        if (adb.Read(addrman))
            LogPrintf("Loaded %i addresses from peers.dat  %dms\n", addrman.size(), GetTimeMillis() - nStart);
        else {
            addrman.Clear(); // Addrman can be in an inconsistent state after failure, reset it
            LogPrintf("Recreating peers.dat\n");
            DumpAddresses();
        }
    }

    if (m_use_addrman_outgoing) {
        // Load addresses from anchors.dat
        m_anchors = ReadAnchors(GetDataDir() / ANCHORS_DATABASE_FILENAME);
        if (m_anchors.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {
            m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);
        }
        LogPrintf("%i block-relay-only anchors will be tried for connections.\n", m_anchors.size());
    }
    // ...
}
----

Then, the `threadSocketHandler` is started. It enable the node to accept new connections (function `CConnman::AcceptConnection(...)`), to receive and send data.

//Next, the  `threadDNSAddressSeed`, `threadOpenAddedConnections`, `ThreadOpenConnections` and the `ThreadMessageHandler` levle.




