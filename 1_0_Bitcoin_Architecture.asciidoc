[[bitcoin-architecture]]
== 1.0 Bitcoin Architecture

=== Executables

To be able to interact with Bitcoin network, the user needs to connect to a Bitcoin node, a software whose main purposes are:

* Download the blockchain.
* Enforce the rules of the network.
* Validate and relay the transactions.

Running your own node is of utmost importance when spending or transferring the bitcoins. The other option is trusting other nodes which is a major security hole. When doing it, the user is not only leaking personal data, but also trusting in the data and in the rules defined by others, who can be malicious agents or harmful to the network or even harmful to the user.

The other component necessary to store and move coins is a wallet. The primary function of the wallet is to manage the private keys and sign transactions.

Bitcoin protocol does not have the concept of accounts, like banks. Wallets manage a pool of unfathomable random numbers called private keys, which should be kept secret by the user. Bitcoin addresses are derived from these private keys and they can be used to receive coins (and move them later). Only one receiving address must be used for each transaction.

Signing a transaction means the user is moving the money and has authorized the transaction. To create the signature, the wallet will use the private key associated to the coin(s) the user wants to spend.

Node and wallet are completely different things, although they can eventually come together in the same software. Node is related to bitcoin network and protocol while a wallet is related to the one’s private keys and transactions. It is very important to know the difference between these two concepts to be able to have a better understanding of Bitcoin architecture.

// ---

Bitcoin Core has been the reference implementation since its first version, and it is not only one software. Bitcoin Core is a solution that includes a node, a graphic interface, and a command line interface. There are also wallet features (including a sophisticated coin selection) but since version v0.21, wallets are no longer created by default. The reason is to make the use of multiple wallets more intuitive.

To start a node simple run the main app bitcoind implemented in src/bitcoind.cpp. This executable is expected to run as a daemon (in background). It also provides a REST interface, so anyone authorized can access and work with the node.

After running the daemon, the user will be able to interact with the node through a command-line application called bitcoin-cli that is implemented in src/bitcoin-cli.cpp. It implements some RPC commands that are sent via REST to the node (the bitcoind daemon) and process the results.

Another and simpler and friendly option to start the node and operate it is starting bitcoin-qt, implemented in src/qt/main.cpp. This one is an intuitive graphic interface, which all interactions happen through buttons. The user can create multiple wallets and check other information about the node as the peers’ connection and network statistics. 


.Bitcoin Core Executables
image::images/chapter_1_0/executables.svg[]
[CChainParams, align="center"]

{empty} +

=== Protocol - P2P

Bitcoin is a peer-to-peer protocol. There is no central server that can determine the rules. So, to be able to communicate with other peers and exchange information about the network, transactions and the chain state, the nodes need to establish a common protocol, so they can understand each other.

The file `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/protocol.h[src/protocol.h]` defines all types of messages (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/protocol.h#L62[namespace NetMsgType]`) that will be used in this communication. As can be seen in the code below, each message has a comment with a succinct description of its purpose.

[source,c++]  
----
/**
 * Bitcoin protocol message types. When adding new message types, don't forget
 * to update allNetMessageTypes in protocol.cpp.
 */
namespace NetMsgType {

/**
 * The version message provides information about the transmitting node to the
 * receiving node at the beginning of a connection.
 */
extern const char* VERSION;
/**
 * The verack message acknowledges a previously-received version message,
 * informing the connecting node that it can begin to send other messages.
 */
extern const char* VERACK;
// ...
/**
 * The inv message (inventory message) transmits one or more inventories of
 * objects known to the transmitting peer.
 */
extern const char* INV;
/**
 * The getdata message requests one or more data objects from another node.
 */
extern const char* GETDATA;
// ...
}
----

But how does the node find the other peers to exchange messages ? When running for first time, the node connect to a bunch of server denominated DNS Seeds which provides a list of IP addresses that are running (or were recently running) a Bitcoin client. After connecting to those IP addresses, the node starts to exchange messages and other new addresses with the peers. +
DNS seeds are  hardcoded and stored in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/chainparams.cpp[src/chainparams.cpp]`.

[source,c++]  
----
vSeeds.emplace_back("seed.bitcoin.sipa.be"); // Pieter Wuille, only supports x1, x5, x9, and xd
vSeeds.emplace_back("dnsseed.bluematt.me"); // Matt Corallo, only supports x9
vSeeds.emplace_back("dnsseed.bitcoin.dashjr.org"); // Luke Dashjr
vSeeds.emplace_back("seed.bitcoinstats.com"); // Christian Decker, supports x1 - xf
vSeeds.emplace_back("seed.bitcoin.jonasschnelli.ch"); // Jonas Schnelli, only supports x1, x5, x9, and xd
----

New peers can be also manually added with the command `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L442[-addnode=<addr>]`. The connection parameters, like `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net.h#L78[DEFAULT_MAX_PEER_CONNECTIONS]` or `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net.h#L64[MAX_ADDNODE_CONNECTIONS]`, can be found in the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net.h[net.h]` file.

== Concurrency model

The class thread represents a single thread of execution. Threads allow multiple functions to execute concurrently.

Most threads are starded (directly or indirectly) in `init.cpp`.

=== `init.cpp:AppInitMain(...)` and `CConnman::Start(...)`

When the node starts, `init.cpp:AppInitMain(...)` calls `node.connman->Start(*node.scheduler, connOptions)`. In the `CConnman::Start(...)` the network-related threads are instantiated and excuted.

=== TraceThread

`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.h#L432[TraceThread]` is a wrapper for a function that just calls it once. It also names the thread and handles `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.h#L441[boost::thread_interrupted]` exception. In Bitcoin Core code, it is usually used as _fn_ argument to thread constructor `std::thread (Fn&& fn, Args&&... args)`. It is defined in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.h[src/util/system.h]`.

[source,c++]  
----
template <typename Callable> void TraceThread(const char* name,  Callable func)
{
    util::ThreadRename(name);
    try
    {
        LogPrintf("%s thread start\n", name);
        func();
        LogPrintf("%s thread exit\n", name);
    }
    catch (const boost::thread_interrupted&)
    {
        LogPrintf("%s thread interrupt\n", name);
        throw;
    }
    catch (const std::exception& e) {
        PrintExceptionContinue(&e, name);
        throw;
    }
    catch (...) {
        PrintExceptionContinue(nullptr, name);
        throw;
    }
}
----

=== Script Verification

The function that perform the script verification is `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/script/interpreter.cpp#L1937[bool src/script/interpreter.cpp:VerifyScript(...)]`. It is called in at least three points of the application:

* When the node receives a new transaction, which is handled by `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2274[void src/net_processing.cpp:PeerManager::ProcessMessage(...)]` when the received message is a _tx_ type (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2940[if (msg_type == NetMsgType::TX)]`).

* When the node wants to broadcast a new transaction. It is done by `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/node/transaction.cpp#L29[TransactionError src/node/transaction.cpp:BroadcastTransaction(...)]`.

* When receiving a new block, `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2274[void net_src/processing.cpp:PeerManager::ProcessMessage(...)]` will identify a _getblocks_ message type (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2754[if (msg_type == NetMsgType::GETBLOCKS)]`) and https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2779[will call] `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2744[bool src/validation.cpp:CChainState::ActivateBestChain(...)]`.

In the fist two case, `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1062[static bool validation.cpp:AcceptToMemoryPool(...)]` function is called to handle the new transaction, as can be seen in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L3006[ProcessMessage(...)]` and `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/node/transaction.cpp#L66[BroadcastTransaction(...)]`. It will try to add the transaction to mempool. In the last case, the function that will handle the new block is `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1946[bool src/validation.cpp:CChainState::ConnectBlock(...)]`. Both of them end up calling `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1516[src/validation.cpp:bool CheckInputScripts(...)]`.

`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1516[CheckInputScripts(...)]` validates the scripts of all the inputs of the `const CTransaction& tx` transaction passed as parameter. However, the relevant parameter in this context is the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L201[std::vector<CScriptCheck> *pvChecks = nullptr]`. `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.h#L252[CScriptCheck]` is a closure representing one script verification and it stores references to the spending transaction.

[source,c++]  
----
class CScriptCheck
{
    private:
        CTxOut m_tx_out;
        const CTransaction *ptxTo;
        unsigned int nIn;
        unsigned int nFlags;
        bool cacheStore;
        ScriptError error;
        PrecomputedTransactionData *txdata;
    // ...
}
----

The `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.h#L252[CScriptCheck]` method that matters is the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1464[bool src/validation.cpp:CScriptCheck::operator()()]`. It overloads the operator `()` and perform the script validation (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1467[VerifyScript(...)]`).

[source,c++]  
----
bool CScriptCheck::operator()() {
    const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;
    const CScriptWitness *witness = &ptxTo->vin[nIn].scriptWitness;
    return VerifyScript(scriptSig, m_tx_out.scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, m_tx_out.nValue, cacheStore, *txdata), &error);
}
----

So if the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1561[std::vector<CScriptCheck> *pvChecks]` is not null, the  `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1516[CheckInputScripts(...)]` will add each script validation (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1560[CScriptCheck check]`) to the vector, so they can be executed in parallel. Otherwise, the script is verified immediately.

[source,c++]  
----
bool CheckInputScripts(const CTransaction& tx, ..., std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
{
    // ...
    for (unsigned int i = 0; i < tx.vin.size(); i++) {
        CScriptCheck check(txdata.m_spent_outputs[i], tx, i, flags, cacheSigStore, &txdata);
        if (pvChecks) {
            pvChecks->push_back(CScriptCheck());
            check.swap(pvChecks->back());
        } else if (!check()) {
            // ...
        }
        // ...
    }
    // ...
}
----

The only function that makes use of script validation parallelization is the aforementioned `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1946[bool CChainState::ConnectBlock(...)]` due to the quantity of transactions in a block. If the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2134[g_parallel_script_checks]` is true, the script verification vector that has been filled in `CheckInputScripts(...)` is allocated in  `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2134[CCheckQueueControl<CScriptCheck> control(...)]`. The `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2218[control.Wait()]` initiates the their execution and wait for the end. +
`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L135[g_parallel_script_checks]` is a global parameter and it will be better detailed soon.

[source,c++]  
----
bool CChainState::ConnectBlock(const CBlock& block, ...)
{
    // ...
    CCheckQueueControl<CScriptCheck> control(fScriptChecks && g_parallel_script_checks ? &scriptcheckqueue : nullptr);
    // ...

    for (unsigned int i = 0; i < block.vtx.size(); i++)
    {
        if (!tx.IsCoinBase())
        {
            std::vector<CScriptCheck> vChecks;
            if (!CheckInputScripts(tx,..., g_parallel_script_checks ? &vChecks : nullptr)) { /*...*/ }
            control.Add(vChecks);  
        }
    }

    if (!control.Wait()) {
        LogPrintf("ERROR: %s: CheckQueue failed\n", __func__);
        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, "block-validation-failed");
    }
}
----

The code that will be excute the work (in this case, it is the script verification) can be found in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/checkqueue.h#L66[bool src/checkqueue.h:CCheckQueue::Loop(...)]`.

[source,c++]  
----
template <typename T>
class CCheckQueue
{
private:
    /** Internal function that does bulk of the verification work. */
    bool Loop(bool fMaster = false)
    {
        // ...
        do {
            // ...
            // execute work
            for (T& check : vChecks)
                if (fOk)
                    fOk = check();
            vChecks.clear();
        } while (true);
}
----

The number of script-checking threads is defined in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1263[init.cpp:AppInitMain(...)]`. The user can set the number of the threads using the argument `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L418[-par]`. If the number is negative, it will limit the threads. +
If the user does not pass the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L418[-par]` parameter, `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.cpp#L1277[src/util/system.cpp:GetNumCores()]` is called to get the number of concurrent threads supported by the implementation. Then 1 is subtracted from this number because the the main thread is already being  used. `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.cpp#L1277[GetNumCores()]` is just a wrapper for C++ standard function `std::thread::hardware_concurrency()`. +
There is also a maximum number of dedicated script-checking threads allowed, that is 15 (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.h#L70[MAX_SCRIPTCHECK_THREADS]`).
Note that `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1333[g_parallel_script_checks]` is set to true, allowing parallelization in the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1946[ConnectBlock(...)]` function.

[source,c++]  
----
bool AppInitMain(...)
{
    //...
    int script_threads = args.GetArg("-par", DEFAULT_SCRIPTCHECK_THREADS);
    if (script_threads <= 0) {
        // -par=0 means autodetect (number of cores - 1 script threads)
        // -par=-n means "leave n cores free" (number of cores - n - 1 script threads)
        script_threads += GetNumCores();
    }

    // Subtract 1 because the main thread counts towards the par threads
    script_threads = std::max(script_threads - 1, 0);

    // Number of script-checking threads <= MAX_SCRIPTCHECK_THREADS
    script_threads = std::min(script_threads, MAX_SCRIPTCHECK_THREADS);

    LogPrintf("Script verification uses %d additional threads\n", script_threads);
    if (script_threads >= 1) {
        g_parallel_script_checks = true;
        for (int i = 0; i < script_threads; ++i) {
            threadGroup.create_thread([i]() { return ThreadScriptCheck(i); });
        }
    }
    //...
}
----

And finally the command `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1335[ThreadScriptCheck(i)]` simply initiate a new worker thread one or several times, according to the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1318[script_threads]` value. Its implementation can be found in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1823[src/validation.cpp]`.

[source,c++]  
----
static CCheckQueue<CScriptCheck> scriptcheckqueue(128);

void ThreadScriptCheck(int worker_num) {
    util::ThreadRename(strprintf("scriptch.%i", worker_num));
    scriptcheckqueue.Thread();
}
----

Therefore, these are the main steps in verifying the script. However, there is already a change after version v0.21, making it more efficient and reducing the dependency on `boost / thread`. It can be verified in the  https://github.com/bitcoin/bitcoin/pull/18710[PR #18710]. There is also an interesting https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/test/checkqueue_tests.cpp[CCheckQueue unit tests], implemented in the https://github.com/bitcoin/bitcoin/pull/9497/files[PR #9497].


=== Loading blocks

One of the first thing the node need to do is load the blocks and decides which chain to work.

The thread `g_load_block` invoke the function `void ThreadImport(...)` to load the blocks on startup. If the user is rebuilding the blockchain index (`-reindex`) or is loading blocks directly from files (`-loadblock`), it will be handled in this thread. After loading the blocks, it tries to find the best chain in `CChainState::ActivateBestChain(...)`.

It happens in the `init.cpp:AppInitMain(...)`.

[source,c++]  
----
std::vector<fs::path> vImportFiles;
for (const std::string& strFile : args.GetArgs("-loadblock")) {
    vImportFiles.push_back(strFile);
}

g_load_block = std::thread(&TraceThread<std::function<void()>>, "loadblk", [=, &chainman, &args] {
    ThreadImport(chainman, vImportFiles, args);
});
----

=== Servicing RPC Calls

To allow user to interact with the node, an HTTP server should be enabled to process the requests. In order to do it, the `init.cpp:AppInitServers(...)` calls `httpserver.cpp:InitHTTPServer()` that, as the name implies, initializes the server and `httpserver.cpp:StartHTTPServer()` that constructs new thread objects.

`g_thread_http` is event dispatcher thread, that manages the http event loop. It is interrupted when  InterruptHTTPServer() is called.

`g_thread_http_workers` distributes the work over multiple threads and handles longer requests off the event loop thread. `HTTPWorkQueueRun` is a simple wrapper to set thread name and run work queue. The number of the threads to service RPC calls is defined by the configuration argument `-rpcthreads` or `httpserver.h:DEFAULT_HTTP_THREADS=4`, whichever is greater.

[source,c++]  
----
static std::thread g_thread_http;
static std::vector<std::thread> g_thread_http_workers;

void StartHTTPServer()
{
    LogPrint(BCLog::HTTP, "Starting HTTP server\n");
    int rpcThreads = std::max((long)gArgs.GetArg("-rpcthreads", DEFAULT_HTTP_THREADS), 1L);
    LogPrintf("HTTP: starting %d worker threads\n", rpcThreads);
    g_thread_http = std::thread(ThreadHTTP, eventBase);

    for (int i = 0; i < rpcThreads; i++) {
        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue, i);
    }
}
----

=== Load Peer Adresses From DNS Seeds

As said before, the node initially queries the hardcoded DNS Seeds to find new peers to connect to.

`net.h:std::thread threadDNSAddressSeed` is a thread created with `CConnman::ThreadDNSAddressSeed(...)` wrapped into `TraceThread(...)`. It will run once when node starts.

It is called in `init.cpp:AppInitMain(...)` function when the command `node.connman->Start(*node.scheduler, connOptions)` is executed.

Note if a particular list is provided in the configuration parameters (`-dnsseed`), this thread will not be instantiated.

[source,c++]  
----
if (!gArgs.GetBoolArg("-dnsseed", true))
    LogPrintf("DNS seeding disabled\n");
else
    threadDNSAddressSeed = std::thread(&TraceThread<std::function<void()> >, "dnsseed", std::function<void()>(std::bind(&CConnman::ThreadDNSAddressSeed, this)));
----

[[send-and-receive-messages-to-and-from-peers]]
=== Send And Receive Messages To And From Peers

`std::thread threadSocketHandler` is created using `CConnman::ThreadSocketHandler()` method wrapped into `TraceThread(...)`.

[source,c++]  
----
bool CConnman::Start(...)
{
    threadSocketHandler = std::thread(&TraceThread<std::function<void()> >, "net", std::function<void()>(std::bind(&CConnman::ThreadSocketHandler, this)));
}
----

It seems strange at first, because `TraceThread(...)` ensures unique execution and the node will send and receive messages several time while connected, not just one time.

But a close look into the `CConnman::ThreadSocketHandler()` code shows it has  a loop that keeps running until be eventually interrupted by the `interruptNet` flag.

[source,c++]  
----
void CConnman::ThreadSocketHandler()
{
    while (!interruptNet)
    {
        DisconnectNodes();
        NotifyNumConnectionsChanged();
        SocketHandler();
    }
}
----

This flag is set `false` only in the `CConnman::Interrupt()` that interrupts all connections.

`CConnman::DisconnectNodes()` disconnect any connected nodes if the `fNetworkActive` is false. It can be disabled/enabled by `setnetworkactive` RPC command. The function also disconnects unused nodes and delete disconnected nodes.

`NotifyNumConnectionsChanged()` updates the nubmer of connections and ,if the client interface is enabled, it notifies when the number of connections change.

`SocketHandler()` handles socket connections, incoming messages (`pnode->vRecvMsg`) and the messages to send (`pnode->cs_vSend`);

=== Initializing Network Connections

The thread `std::thread threadOpenConnections` opens and manages connections to other peers. Before instantiating this thread, it is checked if the application is started with `-connect=0` or `-connect=<ip>`. +
If `-connect` is set to 0, this `threadOpenConnections` thread will not be created. +
If an specific IP is set, there will be only one active outbound connection and with that IP. +
If the `-connect` parameter is not passed, all the outbound network connections will be initiate.

[source,c++]  
----
if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty())
        threadOpenConnections = std::thread(&TraceThread<std::function<void()> >, "opencon", std::function<void()>(std::bind(&CConnman::ThreadOpenConnections, this, connOptions.m_specified_outgoing)));
----

The total number of outbound connection `m_max_outbound` is defined in `src/net.h`. It usually will be 11, the sum of the full relay (8), block relay (2) only and feeler (1) connections.

[source,c++]  
----
/** Maximum number of automatic outgoing nodes over which we'll relay everything (blocks, tx, addrs, etc) */
static const int MAX_OUTBOUND_FULL_RELAY_CONNECTIONS = 8;
/** Maximum number of addnode outgoing nodes */
static const int MAX_ADDNODE_CONNECTIONS = 8;
/** Maximum number of block-relay-only outgoing connections */
static const int MAX_BLOCK_RELAY_ONLY_CONNECTIONS = 2;
/** Maximum number of feeler connections */
static const int MAX_FEELER_CONNECTIONS = 1;

void Init(...) {
    m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;
}
----

The use of `-connect=0` to disable automatic outbound connections has been implemented in https://bitcoin.org/en/release/v0.14.0#p2p-protocol-and-network-code[v0.14], with the the https://github.com/bitcoin/bitcoin/pull/9002[PR #9002].

=== Opening Added Network Connections

`std::thread threadMessageHandler` is created using `CConnman::ThreadOpenAddedConnections` wrapped into `TraceThread(...)`.

`CConnman::ThreadOpenAddedConnections()` calls `CConnman::GetAddedNodeInfo()` to retrieve the nodes that has been` added manually and try to open connection with them calling `OpenNetworkConnection(...)`.

[source,c++]  
----
// Initiate manual connections
threadOpenAddedConnections = std::thread(&TraceThread<std::function<void()> >, "addcon", std::function<void()>(std::bind(&CConnman::ThreadOpenAddedConnections, this)));
----

=== Process Messages from `net` -> `net_processing`

When the node starts, `init.cpp:AppInitMain(...)` calls `node.connman->Start(*node.scheduler, connOptions)`.

`std::thread threadMessageHandler` is created using `CConnman::ThreadMessageHandler` wrapped into `TraceThread(...)`.

[source,c++]  
----
bool CConnman::Start(...)
{
    // Process messages
    threadMessageHandler = std::thread(&TraceThread<std::function<void()> >, "msghand", std::function<void()>(std::bind(&CConnman::ThreadMessageHandler, this)));
}
----

As already seen in <<send-and-receive-messages-to-and-from-peers>>, this code will not be executed once. `TraceThread(...)` ensures unique execution but the `CConnman::ThreadMessageHandler()` has a loop that keeps running until be eventually interrupted by the `flagInterruptMsgProc` flag.

This flag is set `true` only in the `CConnman::Interrupt()` that interrupts all connections.

[source,c++]  
----
void CConnman::ThreadMessageHandler()
{
    while (!flagInterruptMsgProc)
    {
        // ...

        for (CNode* pnode : vNodesCopy)
        {
            if (pnode->fDisconnect)
                continue;

            // Receive messages
            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);
            // ...
            // Send messages
            {
                LOCK(pnode->cs_sendProcessing);
                m_msgproc->SendMessages(pnode);
            }
            // ...
        }

        // ...
    }
}
----
