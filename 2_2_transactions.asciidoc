[[bitcoin-transaction]]
== 2.1. Transaction

The interface the user uses to send the coin to a Bitcoin address is implemented by `src/qt/sendcoinsdialog.cpp`. When the user clicks on the  'Send' button, the method `void SendCoinsDialog::on_sendButton_clicked()` is triggered.

This method calls `bool SendCoinsDialog::PrepareSendText(...)`, which builds the transaction.

[source,c++]  
----
void SendCoinsDialog::on_sendButton_clicked()
{
    if(!model || !model->getOptionsModel())
        return;

    QString question_string, informative_text, detailed_text;
    if (!PrepareSendText(question_string, informative_text, detailed_text)) return;
    assert(m_current_transaction);

    // ...
}
----

The interface allows users to add as many recipients as they want. Each of them is handled by the `SendCoinsEntry` class.
This class is a subclass of QStackedWidget ann represents a single entry in the dialog for sending bitcoins.

The method `SendCoinsEntry::validate(...)` makes some basic verification like verifying the address, checking that the amount is different from 0 and rejecting dust values.

`SendCoinsEntry::getValue()`` returns a `SendCoinsRecipient` instance (object), that represents all the information inserted by user on the screen, like `address` of the recipient, `label` and `amount`. 

For every `SendCoinsEntry` (recipent) user inserted, a `SendCoinsRecipient` is created by calling `SendCoinsEntry::getValue()`. Those `SendCoinsRecipient` instances are allocated in a list `QList<SendCoinsRecipient> recipients`.

The recipients list is passed as argument to create a new `WalletModelTransaction` and assign it to the `m_current_transaction` property of `SendCoinsDialog` object.

The next command updates the state of the m_coin_control, that is a property of the class that is a instance of `CCoinControl` class and it is designed to allow user to customize some features of the transactions, as custom change destination, BIP 125 (RBF) and selecting which UTXO to spend.

Then the method `WalletModel::prepareTransaction(...)` is called to create the transaction.

[source,c++]  
----
bool SendCoinsDialog::PrepareSendText(QString& question_string, QString& informative_text, QString& detailed_text)
{
    // ...

    m_current_transaction = std::make_unique<WalletModelTransaction>(recipients);
    WalletModel::SendCoinsReturn prepareStatus;

    updateCoinControlState(*m_coin_control);

    prepareStatus = model->prepareTransaction(*m_current_transaction, *m_coin_control);

    // ...
}
----

=== CScript

The process of creating transaction involves multiple steps. The first one we will look over is the creation of the `scriptPubKey` for each recipient.

A `scriptPubKey` (more easily thought of as a “locking script”) is a script that you put on an output to prevent others from spending it. Only the recipient will be ablet to solve the script and spend the output.

There are a few set patterns of locking scripts that are commonly used in bitcoin: `Pay To Pubkey (P2PK)`, `Pay To Pubkey Hash (P2PKH)`, `Pay To Multisig (P2MS)`, `Pay To Script Hash (P2SH), NULL DATA (provably unspendable)`, `Pay To Witness Public Key Hash (P2WPKH)` and `Pay to Witness Script Hash (P2WSH)`.

Each of those patterns has a instructions set implemented in a programming language called `Script`, that is simple, stack-based, and processed from left to right. It is intentionally not Turing-complete, with no loops. 

The table below shows the commands of each pattern.

[%autowidth]
|===
|Script |ScriptPubKey Instructions 

|P2PK
|`<pubKey>` `OP_CHECKSIG`

|P2PKH
|`<pubKey>` `OP_DUP` `OP_HASH160` `<pubKeyHash>` `OP_EQUALVERIFY` `OP_CHECKSIG` 

|P2MS
|`OP_M` `<pubKey1>` `<pubKey2>` `...` `<pubKeyN>` `OP_N` `OP_CHECKMULTISIG`

|P2SH
|`OP_HASH160` `scriptHash` `OP_EQUAL`

|NULL DATA
|`OP_RETURN` `arbitrary data`

|P2WPKH
|`OP_0` `20-byte hash`

|P2WSH
|`OP_0` `32-byte hash`
|===

So how does Bitcoin Core know which scriptPubKey is the most suitable for the address inserted by the user ? There's some patterns in the address format that helps identify it. The forementioned function `WalletModel::prepareTransaction(...)` calls another function called `DecodeDestination(...)` that will try to find those patterns and will return a data type called `CTxDestination` based on the result.

[source,c++]  
----
WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransaction &transaction, const CCoinControl& coinControl)
{
    CAmount total = 0;
    bool fSubtractFeeFromAmount = false;
    QList<SendCoinsRecipient> recipients = transaction.getRecipients();
    std::vector<CRecipient> vecSend;

    // some validations

    // Pre-check input data for validity
    for (const SendCoinsRecipient &rcp : recipients)
    {
        if (rcp.fSubtractFeeFromAmount)
            fSubtractFeeFromAmount = true;
        {   // User-entered bitcoin address / amount:
            
            // more validations

            CScript scriptPubKey = GetScriptForDestination(DecodeDestination(rcp.address.toStdString()));

            CRecipient recipient = {scriptPubKey, rcp.amount, rcp.fSubtractFeeFromAmount};

            vecSend.push_back(recipient);

            total += rcp.amount;
        }
    }

    // ...
----

`CTxDestination` is an instance of `std::variant`, what allows it to hold multiple types of data. It can hold the following types: `CNoDestination`, `PKHash`, `ScriptHash`, `WitnessV0ScriptHash`, `WitnessV0KeyHash` and `WitnessUnknown`. + 
They represent internal data types encoded in a bitcoin address. The table below shows the variant type and its equivalent locking script (which is called `destination` throughout the code).

[%autowidth]
|===
|Type | Destination 

|CNoDestination
|no destination set

|PKHash
|TxoutType::PUBKEYHASH destination (P2PKH)

|ScriptHash
|TxoutType::SCRIPTHASH destination (P2SH)

|WitnessV0ScriptHash
|TxoutType::WITNESS_V0_SCRIPTHASH destination (P2WSH)

|WitnessV0KeyHash
|TxoutType::WITNESS_V0_KEYHASH destination (P2WPKH)

|WitnessUnknown
|TxoutType::WITNESS_UNKNOWN/WITNESS_V1_TAPROOT destination (P2W???)
|===

`PKHash`, `ScriptHash` and `WitnessV0KeyHash` are subclass of `BaseHash<uint160>`. + 
`WitnessV0ScriptHash` is subclass of `BaseHash<uint256>`. + 
`CNoDestination` and `WitnessUnknown` have no superclass.


`BaseHash<HashType>` implements basic hash operations. An `uint256` holds a 256-bit hash code. It contains an `uint8_t` array of length 256/32=8 to hold the hash code. Another similar data structure `uint160`, defined in the same header file, holds a 160-bit hash code. It has an unsignedint array of length 160/32=5 to hold the hash code. These two classes share the same base class `base_blob`.

// continue with DecodeDestination

Now that we've seen the data structures involved in the decoding process, let's look at the function `CTxDestination DecodeDestination(...)` in more detail. This function is locate at `/src/key_io.cpp` file.

[source,c++]  
----
CTxDestination DecodeDestination(const std::string& str, const CChainParams& params, std::string& error_str)
{
    std::vector<unsigned char> data;
    uint160 hash;
    error_str = "";
    if (DecodeBase58Check(str, data, 21)) {
        // base58-encoded Bitcoin addresses.
        // Public-key-hash-addresses have version 0 (or 111 testnet).
        // The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key.
        const std::vector<unsigned char>& pubkey_prefix = params.Base58Prefix(CChainParams::PUBKEY_ADDRESS);
        if (data.size() == hash.size() + pubkey_prefix.size() && std::equal(pubkey_prefix.begin(), pubkey_prefix.end(), data.begin())) {
            std::copy(data.begin() + pubkey_prefix.size(), data.end(), hash.begin());
            return PKHash(hash);
        }
        // Script-hash-addresses have version 5 (or 196 testnet).
        // The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script.
        const std::vector<unsigned char>& script_prefix = params.Base58Prefix(CChainParams::SCRIPT_ADDRESS);
        if (data.size() == hash.size() + script_prefix.size() && std::equal(script_prefix.begin(), script_prefix.end(), data.begin())) {
            std::copy(data.begin() + script_prefix.size(), data.end(), hash.begin());
            return ScriptHash(hash);
        }

        // Set potential error message.
        // This message may be changed if the address can also be interpreted as a Bech32 address.
        error_str = "Invalid prefix for Base58-encoded address";
    }
    // more code
----

The first part of the function handles the cases of the P2PKH or the P2SH. As mentioned previously, P2PK or P2SH are base58-encoded addess. So the first thing that code snippet above does is check if the address inserted by user is compatible with base58 format `if (DecodeBase58Check(str, data, 21))`. The file that implements the base58 functions is `src/base58.cpp`.

If base58 decoding is successful, then the function tries to check if it is a Public-key-hash-addresses (`RIPEMD160(SHA256(pubkey))`) or a Script-hash-addresses (`RIPEMD160(SHA256(cscript))`). To do it, the `CChainParams::PUBKEY_ADDRESS` and `CChainParams::SCRIPT_ADDRESS` are used. The PKH addresses have version 0 (or 111 testnet) and SH addresses have version 5 (or 196 testnet). It can be verified in the file `src/chainparams.cpp`.

The function will return `PKHash(hash)` or `ScriptHash(hash)` if one of those conditions is met. Since PKH and SH are 160-bit RIPEMD-160 hashes, both are subclasses of BaseHash<uint160>. They are defined in the file `src/standard.cpp`.

[source,c++]  
----
struct PKHash : public BaseHash<uint160>
{
    PKHash() : BaseHash() {}
    explicit PKHash(const uint160& hash) : BaseHash(hash) {}
    explicit PKHash(const CPubKey& pubkey);
    explicit PKHash(const CKeyID& pubkey_id);
};

// ...

struct ScriptHash : public BaseHash<uint160>
{
    ScriptHash() : BaseHash() {}
    // These don't do what you'd expect.
    // Use ScriptHash(GetScriptForDestination(...)) instead.
    explicit ScriptHash(const WitnessV0KeyHash& hash) = delete;
    explicit ScriptHash(const PKHash& hash) = delete;

    explicit ScriptHash(const uint160& hash) : BaseHash(hash) {}
    explicit ScriptHash(const CScript& script);
    explicit ScriptHash(const CScriptID& script);
};
----

`CChainParams` defines various tweakable parameters of a given instance of the Bitcoin system, such as `powLimit`, `nSubsidyHalvingInterval`, `nPowTargetTimespan`, `checkpointData` and the DNS Seeds. + 
There are four `CChainParams`: the main network (`class CMainParams`), public test network (`class CTestNetParams`), regression test mode (`CRegTestParams`) and the new test network called Signet which adds an additional signature requirement to block validation (class `SigNetParams`).

[source,c++]  
----
class CMainParams : public CChainParams {
    base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);
    base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);
    // ...
    bech32_hrp = "bc";
    // ...
    m_is_test_chain = false;
    //...
}
class CTestNetParams : public CChainParams {
    // ...
    base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);
    base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);
    // ...
    bech32_hrp = "bc";
    // ...
    m_is_test_chain = true;
    //...
}
----

If the address is not base58 encoded, the content of the `data` variable is cleared and then decode the address using bech32 in the line `auto bech = bech32::Decode(str);`. The file that implements the bech32 functions are in the `src/bech32.cpp` file.

[source,c++]  
----
CTxDestination DecodeDestination(const std::string& str, const CChainParams& params)
{
    std::cout << str << std::endl;
    std::vector<unsigned char> data;
    uint160 hash;
    // ... code that checks the address is a PKH or a SH
    data.clear();
    auto bech = bech32::Decode(str);
    if (bech.second.size() > 0 && bech.first == params.Bech32HRP()) {
        // Bech32 decoding
        int version = bech.second[0]; // The first 5 bit symbol is the witness version (0-16)
        // The rest of the symbols are converted witness program bytes.
        data.reserve(((bech.second.size() - 1) * 5) / 8);
        if (ConvertBits<5, 8, false>([&](unsigned char c) { data.push_back(c); }, bech.second.begin() + 1, bech.second.end())) {
            if (version == 0) {
                {
                    WitnessV0KeyHash keyid;
                    if (data.size() == keyid.size()) {
                        std::copy(data.begin(), data.end(), keyid.begin());
                        return keyid;
                    }
                }
                {
                    WitnessV0ScriptHash scriptid;
                    if (data.size() == scriptid.size()) {
                        std::copy(data.begin(), data.end(), scriptid.begin());
                        return scriptid;
                    }
                }
                return CNoDestination();
            }
            if (version > 16 || data.size() < 2 || data.size() > 40) {
                return CNoDestination();
            }
            WitnessUnknown unk;
            unk.version = version;
            std::copy(data.begin(), data.end(), unk.program);
            unk.length = data.size();
            return unk;
        }
    }
    return CNoDestination();
}
----

// TODO: Check
// data.reserve(((bech.second.size() - 1) * 5) / 8);
// if (ConvertBits<5, 8, false>([&](unsigned char c) { data.push_back(c); }, bech.second.begin() + 1, bech.second.end())) 

The variable `bech` is a `std::pair<std::string, std::vector<uint8_t>>` type. The fist element `bech.first` (`std::string`) is the HRP (human-readable part) and the second (`std::vector<uint8_t>`) is the data (the witness program bytes). In the mainnet, HRP has the value "bc", in the signet or testnet, the value is "tb" and in the regression test, it is "bcrt". Those values can be checked in the aforementioned class `CChainParams`.

The next steps are:

. Extract the witness version `int version = bech.second[0]`.
. Check if the version is 0. There's no current implementation for others witness versions.
. If the data (witness program) size is 20-byte , then a `WitnessV0KeyHash` instance is returned.
. If the data (witness program) size is 32-byte , then a `WitnessV0ScriptHash` instance is returned.

If none these conditions are not met, it will return a `WitnessUnknown()` instance if the address is a valid bech32 one. Else it will return `CNoDestination` instance.












