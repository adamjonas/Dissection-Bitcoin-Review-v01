[[bitcoin-transaction]]
== 3.0. Serialization - Evolution

=== secure_allocator and zero_after_free_allocator

One of the first difference that can be noticed between the current code and the book code is the `vector_type vch` variable.

In the code analyzed by the book, `vector_type` is a `vector<char>` with a customized allocator (called `secure_allocator`). This customized allocator clears the memory content before releasing the memory to the OS to prevent other processes running in the same machine to read the data. This ensures the security of the data it stores.

In the https://github.com/bitcoin/bitcoin/pull/352[PR #352], the behaviour of locking the content of vector from being paged out of memory was added. `mlock()` lock part of the calling process's virtual address space into RAM, preventing that memory from being paged to the swap area. `munlock()` perform the converse operation,  unlocking part of the calling process's virtual address space, so that pages in the specified virtual address range may once more to be swapped out if required by the kernel memory manager.

[source,c++]  
----
template<typename T>
struct secure_allocator : public std::allocator<T>
{
    // ...
    T* allocate(std::size_t n, const void *hint = 0)
    {
        T *p;
        p = std::allocator<T>::allocate(n, hint);
        if (p != NULL)
            mlock(p, sizeof(T) * n);
        return p;
    }

    void deallocate(T* p, std::size_t n)
    {
        if (p != NULL)
        {
            memset(p, 0, sizeof(T) * n);
            munlock(p, sizeof(T) * n);
        }
        std::allocator<T>::deallocate(p, n);
    }
};
----

However, this behavior has been removed in the https://github.com/bitcoin/bitcoin/pull/740[PR #740] due to perfomance issues. Since `CDataStream` has a wide usage, the use of the `mlock` in `secure_allocator` increased blockchain download by estimate of 40-50x.

The `secure_allocator` name was replaced by `zero_after_free_allocator` and with the `mlock` removal, te code is almost the same as before. This name reflects better the original proposal of this struct of clearing the content before releasing the memory, that is done with the command `memset(p, 0, sizeof(T) * n)` in the `deallocate` function.

=== CHashWriter

In the https://github.com/bitcoin/bitcoin/pull/1567[PR #1567], the class `https://github.com/bitcoin/bitcoin/pull/1567/files#diff-40ab92941994ec9418dbb76ae46d5aef0e4cb8b034f2be2b31562bb9aca8070fR394-R433[CHashWriter]` was added. It is a writer stream (for serialization) that computes a 256-bit hash. Originally, the `https://github.com/bitcoin/bitcoin/pull/1567/files#diff-40ab92941994ec9418dbb76ae46d5aef0e4cb8b034f2be2b31562bb9aca8070fR469-R474[SerializeHash()]` function used to create a memory-backed CDataStream, serialize the object (almost always a CTransaction) to it, and then feed it to SHA256. As most of the time is actually spent in allocating/deallocating the buffer, it is better to do the SHA256 in-place. That is what `CHashWriter` does. It is interesting to note that at the time of this PR, `CHashWriter` still used the OpenSSL library (the https://github.com/bitcoin/bitcoin/pull/1567/files#diff-40ab92941994ec9418dbb76ae46d5aef0e4cb8b034f2be2b31562bb9aca8070fR397[SHA256_CTX] field is an OpenSSL `typedef struct`). 

`CHashWriter` has replaced the `CDataStream` in various locations in the code, as can be seen in the https://github.com/bitcoin/bitcoin/pull/1936[PR #1936], in the commit https://github.com/bitcoin/bitcoin/commit/f50fb5470b1d3a65a513b3a9a77209ccad590a19[f50fb54], https://github.com/bitcoin/bitcoin/pull/6484[PR #6484] and others.

The OpenSSL depency for SHA256 has been removed in the https://github.com/bitcoin/bitcoin/pull/4100[PR #4100], which has replaced OpenSSL hash functions with built-in implementations. The changes in the class `CHashWriter` can be seen in the commit https://github.com/bitcoin/bitcoin/pull/4100/commits/7b4737c87805b464cd47d01a9d814df5e41b8255#diff-d3f64e14005fbfea3d4f72b076764ac897d0df451de0ab2fb1c57a5f87cd793bL29-L66[7b4737c]. +
However, the OpenSSL dependency has only been completely removed recently, in the version https://bitcoin.org/en/release/v0.20.0#build-system[v0.20.0], with the https://github.com/bitcoin/bitcoin/pull/17265[PR #17265].

.Why remove the OpenSSL dependency? 
[NOTE]
===============================
Using third-party libraries reduces the amount of work to be allocated in software development and allows the reuse of well-tested code instead of reinventing the wheel. +
However, this comes at a cost. Third party components may contain vulnerabilities and may not adopt good security practices in the development. In order to minimize this risk, Bitcoin Core tries to minimize any dependencies as much as possible.
===============================


=== CSerializeData

In the https://github.com/bitcoin/bitcoin/pull/2409[PR #2409], the `std::vector<char, zero_after_free_allocator<char> >` was defined as `CSerializeData`, so that it could be reused in `net.h` for network optimalizations. This change have had no effect in the serialization behavior.

[source,c++]  
----
typedef std::vector<char, zero_after_free_allocator<char> > CSerializeData;

class CDataStream
{
protected:
    // ...
    typedef CSerializeData vector_type;
    // ...
}
----

=== CSizeComputer

Another class widely used in Bitcoin Core serialization processes is `CSizeComputer`. It was introduced in the https://github.com/bitcoin/bitcoin/pull/4508[PR #4508] in `https://github.com/bitcoin/bitcoin/pull/4508/files#diff-1c0f9772bbdf8bfc283393a67c305b997a8ab9738d48c160e07d2fa56500a7a0[serialize.h]`. It is a minimal serializer stream implementation that only computes the number of bytes written. It is as efficient as the original function `GetSerializeSize(...)` . This new class was implemented to avoid duplicating the deserialization code when not using the `IMPLEMENT_SERIALIZE` macro. In this particular PR, for example, the `IMPLEMENT_SERIALIZE` https://github.com/bitcoin/bitcoin/pull/4508/files#diff-164bd9e2e30f54d0a79eb7cc372309e2f2155edc6c3f051290ab078f03f6a771L249[has been removed] from `CAddrMan`  because the serialization and deserialization code had very little in common. 

The https://github.com/bitcoin/bitcoin/pull/9039/commits/657e05ab2e87ff725723fe8a375fc3f8aad02126[commit 657e05a] of the https://github.com/bitcoin/bitcoin/pull/9039[PR #9039] has gotten rid
of the specialized `GetSerializeSize` methods in the code, and has started to use the `GetSerializeSize` of the `serialize.h` as a wrapper on top of `CSizeComputer`. It is worth taking a look at this PR, as it implemented several serialization simplifications and optimizations. 

=== Big endian support

The original Satoshi's implementation depended on little-endianness. As the serialization was implemented through simple memory copying, there was no way it would work on other endiannesses. The binary format handled by `serialize.h` depended on the in-memory sizes of char, int, long, ... On a platform on which these were different from x86, the serialized format would be incompatible.

The https://github.com/bitcoin/bitcoin/pull/5510[PR #5510] implemented big endian support, so thenceforth the Bitcoin Core has worked on both endiannesses. The `READDATA` and `WRITEDATA` directives https://github.com/bitcoin/bitcoin/pull/5510/files#diff-1c0f9772bbdf8bfc283393a67c305b997a8ab9738d48c160e07d2fa56500a7a0L116-L117[was replaced] with https://github.com/bitcoin/bitcoin/pull/5510/files#diff-1c0f9772bbdf8bfc283393a67c305b997a8ab9738d48c160e07d2fa56500a7a0R80[functions] that take sized integer types to make use of the proper `https://github.com/bitcoin/bitcoin/pull/5510/files#diff-31f4e9f7c3ca0a1b6ab8e4675b560071f9174c4b017cb3a9db98f78681178595[endian.h]` functions. This replacement also made the code more readable and maintainable.

// Detail more about src/compat/endian.h and src/compat/byteswap.h

=== prevector

The https://github.com/bitcoin/bitcoin/pull/6914[PR #6914] has created a new basic data type called `https://github.com/bitcoin/bitcoin/pull/6914/files#diff-de4950d13265ca967d41d1ea4fed9fe97947f6aa940eb58878b024689bd4de4e[prevector<N, T>]` which is a fully API compatible drop-in replacement for `std::vector<T>`, which typically allocates memory on the heap and often ends up occupying more space than a builtin array, as memory can be allocated to handle future growth. The `prevector` receives an `unsigned int N` parameter and uses it stores up to `N` elements directly, without heap allocation. In the `https://github.com/bitcoin/bitcoin/pull/6914/files#diff-1c0f9772bbdf8bfc283393a67c305b997a8ab9738d48c160e07d2fa56500a7a0[serialize.h]` file, CScript https://github.com/bitcoin/bitcoin/pull/6914/files#diff-1c0f9772bbdf8bfc283393a67c305b997a8ab9738d48c160e07d2fa56500a7a0L23-R23[has been switched] to use this new type, reducing the memory consumption of mempool and chainstate and new functions have been implemented to handle this data structure. However the 
`typedef std::vector<char, zero_after_free_allocator<char> > CSerializeData;` has not changed, since the `prevector` has not supported custom allocators.

// PR #8068 Compact Blocks - implements the BIP 152
// Add COMPACTSIZE wrapper similar to VARINT for serialization 

// https://github.com/bitcoin/bitcoin/pull/9039

=== Transactions Serialization - Original Implementation

//Review
In the early version of Bitcoin (like v0.11), serializing transactions was much simpler. +
In the serialize.h, there was a macro `ADD_SERIALIZE_METHODS` that implemented three methods for serializable objects: `GetSerializeSize()`, `Serialize()` and `Unserialize()`. And they called the method `SerializationOp()`, which were implemented in each serializable class and handle the specific serialization code for that class. So this way, appending `ADD_SERIALIZE_METHODS` in the body of the class caused these three methods to be added as members.

[source,c++]  
----
#define READWRITE(obj)      (::SerReadWrite(s, (obj), nType, nVersion, ser_action))

#define ADD_SERIALIZE_METHODS                                                          \
    size_t GetSerializeSize(int nType, int nVersion) const {                         \
        CSizeComputer s(nType, nVersion);                                            \
        NCONST_PTR(this)->SerializationOp(s, CSerActionSerialize(), nType, nVersion);\
        return s.size();                                                             \
    }                                                                                \
    template<typename Stream>                                                        \
    void Serialize(Stream& s, int nType, int nVersion) const {                       \
        NCONST_PTR(this)->SerializationOp(s, CSerActionSerialize(), nType, nVersion);\
    }                                                                                \
    template<typename Stream>                                                        \
    void Unserialize(Stream& s, int nType, int nVersion) {                           \
        SerializationOp(s, CSerActionUnserialize(), nType, nVersion);                \
    }

// ...

template<typename Stream, typename T>
inline void SerReadWrite(Stream& s, const T& obj, int nType, int nVersion, CSerActionSerialize ser_action)
{
    ::Serialize(s, obj, nType, nVersion);
}

template<typename Stream, typename T>
inline void SerReadWrite(Stream& s, T& obj, int nType, int nVersion, CSerActionUnserialize ser_action)
{
    ::Unserialize(s, obj, nType, nVersion);
}
----

Other relevant macro is the `READWRITE(obj)` that also can be seen above, that is basically a wrapper to `SerReadWrite(...)` and then `::Serialize(...);`.This last function is overloaded for every basic types (`signed` and `unsigned` versions of `char`, `short`, `int`, `long` and `long long`, plus `char`, `float`, `double` and `bool`) and also there were 6 overloaded versions for 6 composite types (`string`, `vector`, `pair`, `map`, `set` and `CScript`). This macro was usually used inside `SerializationOp(...)` to implement the serialization code.

As an example of using the `READWRITE(obj)`, let's see how the Transaction class implemented serialization.

The class `CTransaction` represents basic transaction that is broadcasted on the network and contained in blocks. The class is composed by five members: `uint256 hash`, `int32_t nVersion`, `std::vector<CTxIn> vin`, `std::vector<CTxOut> vout` and `uint32_t nLockTime`. +
The class `CTxOut` represents an output of a transaction. It contains the public key that the next input must be able to sign with to claim it. The fields are `CAmount nValue` and `CScript scriptPubKey`. +
The class `CTxIn` defines an input of a transaction.  It contains the location of the previous transaction's output that it claims and a signature that matches the output's public key. The members are `COutPoint prevout`, `CScript scriptSig` and `uint32_t nSequence`. +
The class `COutPoint` refers to an outpoint - a combination of a transaction hash and an index n into its vout. The fields are `uint256 hash` and `uint32_t n`. +
With some minor additions that we will see later, this data structure for transactions is still basically the same in the current version, v0.21. The diagram below describes it visually. 

.Transaction classes
image::images/chapter_3_0/transaction_classes_v0_11.svg[TxClasses, align="center"]

{empty} +

Each of these classes has its own serialization method, implemented in `SerializationOp(...)`. +
In the class `CTxOut`, for example, the macro READWRITE(nValue); are resolved at compiling time as `(::SerReadWrite(s, (nValue), nType, nVersion, ser_action))`. Since nValue is a `typedef int64_t CAmount`, `SerReadWrite(...)` that will call the appropriate (un)serialization function for that data type (`writedata64(..)` in this case).

[source,c++]  
----
// transaction.h

class CTxOut
{
    // ...
    ADD_SERIALIZE_METHODS;

    template <typename Stream, typename Operation>
    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {
        READWRITE(nValue);
        READWRITE(scriptPubKey);
    }
    // ...
}

// serialize.h

#define READWRITE(obj)      (::SerReadWrite(s, (obj), nType, nVersion, ser_action))

template<typename Stream, typename T>
inline void SerReadWrite(Stream& s, const T& obj, int nType, int nVersion, CSerActionSerialize ser_action)
{
    ::Serialize(s, obj, nType, nVersion);
}

template<typename Stream> inline void Serialize(Stream& s, int64_t a,      int, int=0) { ser_writedata64(s, a); }

template<typename Stream> inline void ser_writedata64(Stream &s, uint64_t obj)
{
    obj = htole64(obj);
    s.write((char*)&obj, 8);
}
----

Other transaction classes followed this scheme. One notable exception that has not used the macro is the class `base_blob` in the file `uint256.h`, the superclass of the `` that represents the 256-bits hash of a transaction.

=== Transactions Serialization - Current Implementation

The current serialization format for transactions is defined in https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki[BIP 144] and it should be backwards compatibility with nodes that is not able to distinguish between the old serialization format (without the witness) and current one.

The table below (from the PR) describes the serialization structure for a segwit transaction and will make it easier to understand the code.

[%autowidth]
|===
|Field Size (byte) |Name| Type| Description

|4
|version
|int32_t
|Transaction data format version

|1
|marker
|char
|Must be zero

|1 
|flag
|char
|Must be nonzero

|1+
|txin_count
|var_int
|Number of transaction inputs

|41+
|txins
|txin[]
|A list of one or more transaction inputs 

|1+
|txout_count
|var_int
|Number of transaction outputs

|9+ 
|txouts
|txouts[]
|A list of one or more transaction outputs 

|1+ 
|script_witnesses
|script_witnesses[]
|The witness structure as a serialized byte array

|4  
|lock_time
|uint32_t
|The block number or timestamp until which the transaction is locked
|===

If the transaction is not segwit the fiedls `marker`, `flag` and `script_witnesses` will not be considered in serialization. In this, if the fifth byte is not a Segwit marker (`x00`), it can be identified as an legacy transaction. 

The method `SerializeTransaction(...)` in `src/primitives/transactions.h` implements the BIP 144 specification. 

[source,c++,linenums]  
----
template<typename Stream, typename TxType>
inline void SerializeTransaction(const TxType& tx, Stream& s) {
    const bool fAllowWitness = !(s.GetVersion() & SERIALIZE_TRANSACTION_NO_WITNESS);

    s << tx.nVersion;
    unsigned char flags = 0;
    // Consistency check
    if (fAllowWitness) {
        /* Check whether witnesses need to be serialized. */
        if (tx.HasWitness()) {
            flags |= 1;
        }
    }
    if (flags) {
        /* Use extended format in case witnesses are to be serialized. */
        std::vector<CTxIn> vinDummy;
        s << vinDummy;
        s << flags;
    }
    s << tx.vin;
    s << tx.vout;
    if (flags & 1) {
        for (size_t i = 0; i < tx.vin.size(); i++) {
            s << tx.vin[i].scriptWitness.stack;
        }
    }
    s << tx.nLockTime;
}
----

The first line `fAllowWitness` checks if witnesses need to be serialized.  `SERIALIZE_TRANSACTION_NO_WITNESS` is a flag that is combined with the protocol version to designate that a transaction should be serialized without witness data. Only if `fAllowWitness` is true, witness data will be serialized. There is a section to detail this flag better.

The next line serialize the `nVersion`, that is member of CTransaction or CMutableTransaction. This field is a 32-bits fixed-size type `int32_t`. So when serialized, it will be the first 4 bytes of the stream as defined in the BIP 144 table first line.

In the next 8 lines, `flags` is set as 0. If `fAllowWitness` is true and the transaction has witness data (`tx.HasWitness()`), the flag is changed to 1. As specified in the third line of the table, the flag field must be nonzero for segwit transaction. Note that this field is a char type  and therefore 1 byte will be written in the stream.

The next line `if (flags) {` checks if flag is true (`not 0`). If so,  this is a segwit transaction, and the `marker` and `flag` must be added. `vinDummy` represents the `marker` field and it is an empty vector (size 0), so `s << vinDummy` adds 1 byte with value `0` to the stream. `s << flags`adds 1 byte with value `1`.

The next steps `s << tx.vin;` and `s << tx.vout;` serialize the two `std::vector`of one or more transaction inputs and outputs. Although it is not evident in the code, the size of each vector is serialzied before them, as described in the table. It is done in the function `void Ser(...)` of the `struct VectorFormatter` that calls `WriteCompactSize(s, v.size());`, which handles the vector size serialization. This call stack will be better analyzed in the `CTxIn` and `CTxOut` serialization.

The next step `if (flags & 1) {` serialize the witness data if the transaction is segwit enabled. Note that the number of script witnesses is not explicitly encoded in the stream as it is the same of `tx.vin.size()`. The `tx.vin[i].scriptWitness.stack` is just a `std::vector<std::vector<unsigned char> >` and the default `vector` and `unsigned char` of `serialize.h` will be used.

And finally, the last command `s << tx.nLockTime` serializes the `nLockTime` which also is a 32-bits fixed-size type `int32_t` (or 4 bytes).

// Calculate the size of tx
// Set the links above

=== SERIALIZE_TRANSACTION_NO_WITNESS Flag

// https://github.com/bitcoin/bitcoin/issues/19477
// https://github.com/bitcoin/bitcoin/pull/19503

=== VectorFormatter